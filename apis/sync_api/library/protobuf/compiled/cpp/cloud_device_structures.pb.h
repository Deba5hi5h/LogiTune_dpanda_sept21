// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cloud_device_structures.proto

#ifndef PROTOBUF_INCLUDED_cloud_5fdevice_5fstructures_2eproto
#define PROTOBUF_INCLUDED_cloud_5fdevice_5fstructures_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "cloud_provisioning_structures.pb.h"
#include "product_state_structures.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_cloud_5fdevice_5fstructures_2eproto 

namespace protobuf_cloud_5fdevice_5fstructures_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_cloud_5fdevice_5fstructures_2eproto
namespace logi {
namespace proto {
class LRProductSnapshot;
class LRProductSnapshotDefaultTypeInternal;
extern LRProductSnapshotDefaultTypeInternal _LRProductSnapshot_default_instance_;
class LRProductSnapshot_ActualDeviceCountEntry_DoNotUse;
class LRProductSnapshot_ActualDeviceCountEntry_DoNotUseDefaultTypeInternal;
extern LRProductSnapshot_ActualDeviceCountEntry_DoNotUseDefaultTypeInternal _LRProductSnapshot_ActualDeviceCountEntry_DoNotUse_default_instance_;
class LRProductSnapshot_ExpectedDeviceCountEntry_DoNotUse;
class LRProductSnapshot_ExpectedDeviceCountEntry_DoNotUseDefaultTypeInternal;
extern LRProductSnapshot_ExpectedDeviceCountEntry_DoNotUseDefaultTypeInternal _LRProductSnapshot_ExpectedDeviceCountEntry_DoNotUse_default_instance_;
class LRProductUpdateSnapshot;
class LRProductUpdateSnapshotDefaultTypeInternal;
extern LRProductUpdateSnapshotDefaultTypeInternal _LRProductUpdateSnapshot_default_instance_;
}  // namespace proto
}  // namespace logi
namespace google {
namespace protobuf {
template<> ::logi::proto::LRProductSnapshot* Arena::CreateMaybeMessage<::logi::proto::LRProductSnapshot>(Arena*);
template<> ::logi::proto::LRProductSnapshot_ActualDeviceCountEntry_DoNotUse* Arena::CreateMaybeMessage<::logi::proto::LRProductSnapshot_ActualDeviceCountEntry_DoNotUse>(Arena*);
template<> ::logi::proto::LRProductSnapshot_ExpectedDeviceCountEntry_DoNotUse* Arena::CreateMaybeMessage<::logi::proto::LRProductSnapshot_ExpectedDeviceCountEntry_DoNotUse>(Arena*);
template<> ::logi::proto::LRProductUpdateSnapshot* Arena::CreateMaybeMessage<::logi::proto::LRProductUpdateSnapshot>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace logi {
namespace proto {

// ===================================================================

class LRProductSnapshot_ExpectedDeviceCountEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<LRProductSnapshot_ExpectedDeviceCountEntry_DoNotUse, 
    ::google::protobuf::uint32, ::google::protobuf::uint32,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<LRProductSnapshot_ExpectedDeviceCountEntry_DoNotUse, 
    ::google::protobuf::uint32, ::google::protobuf::uint32,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    0 > SuperType;
  LRProductSnapshot_ExpectedDeviceCountEntry_DoNotUse();
  LRProductSnapshot_ExpectedDeviceCountEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const LRProductSnapshot_ExpectedDeviceCountEntry_DoNotUse& other);
  static const LRProductSnapshot_ExpectedDeviceCountEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LRProductSnapshot_ExpectedDeviceCountEntry_DoNotUse*>(&_LRProductSnapshot_ExpectedDeviceCountEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class LRProductSnapshot_ActualDeviceCountEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<LRProductSnapshot_ActualDeviceCountEntry_DoNotUse, 
    ::google::protobuf::uint32, ::google::protobuf::uint32,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<LRProductSnapshot_ActualDeviceCountEntry_DoNotUse, 
    ::google::protobuf::uint32, ::google::protobuf::uint32,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    0 > SuperType;
  LRProductSnapshot_ActualDeviceCountEntry_DoNotUse();
  LRProductSnapshot_ActualDeviceCountEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const LRProductSnapshot_ActualDeviceCountEntry_DoNotUse& other);
  static const LRProductSnapshot_ActualDeviceCountEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LRProductSnapshot_ActualDeviceCountEntry_DoNotUse*>(&_LRProductSnapshot_ActualDeviceCountEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class LRProductSnapshot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.LRProductSnapshot) */ {
 public:
  LRProductSnapshot();
  virtual ~LRProductSnapshot();

  LRProductSnapshot(const LRProductSnapshot& from);

  inline LRProductSnapshot& operator=(const LRProductSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LRProductSnapshot(LRProductSnapshot&& from) noexcept
    : LRProductSnapshot() {
    *this = ::std::move(from);
  }

  inline LRProductSnapshot& operator=(LRProductSnapshot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LRProductSnapshot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LRProductSnapshot* internal_default_instance() {
    return reinterpret_cast<const LRProductSnapshot*>(
               &_LRProductSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LRProductSnapshot* other);
  friend void swap(LRProductSnapshot& a, LRProductSnapshot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LRProductSnapshot* New() const final {
    return CreateMaybeMessage<LRProductSnapshot>(NULL);
  }

  LRProductSnapshot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LRProductSnapshot>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LRProductSnapshot& from);
  void MergeFrom(const LRProductSnapshot& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LRProductSnapshot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<uint32, uint32> expected_device_count = 2;
  int expected_device_count_size() const;
  void clear_expected_device_count();
  static const int kExpectedDeviceCountFieldNumber = 2;
  const ::google::protobuf::Map< ::google::protobuf::uint32, ::google::protobuf::uint32 >&
      expected_device_count() const;
  ::google::protobuf::Map< ::google::protobuf::uint32, ::google::protobuf::uint32 >*
      mutable_expected_device_count();

  // map<uint32, uint32> actual_device_count = 3;
  int actual_device_count_size() const;
  void clear_actual_device_count();
  static const int kActualDeviceCountFieldNumber = 3;
  const ::google::protobuf::Map< ::google::protobuf::uint32, ::google::protobuf::uint32 >&
      actual_device_count() const;
  ::google::protobuf::Map< ::google::protobuf::uint32, ::google::protobuf::uint32 >*
      mutable_actual_device_count();

  // string latest_firmware = 4;
  void clear_latest_firmware();
  static const int kLatestFirmwareFieldNumber = 4;
  const ::std::string& latest_firmware() const;
  void set_latest_firmware(const ::std::string& value);
  #if LANG_CXX11
  void set_latest_firmware(::std::string&& value);
  #endif
  void set_latest_firmware(const char* value);
  void set_latest_firmware(const char* value, size_t size);
  ::std::string* mutable_latest_firmware();
  ::std::string* release_latest_firmware();
  void set_allocated_latest_firmware(::std::string* latest_firmware);

  // string latest_firmware_published_timestamp = 5;
  void clear_latest_firmware_published_timestamp();
  static const int kLatestFirmwarePublishedTimestampFieldNumber = 5;
  const ::std::string& latest_firmware_published_timestamp() const;
  void set_latest_firmware_published_timestamp(const ::std::string& value);
  #if LANG_CXX11
  void set_latest_firmware_published_timestamp(::std::string&& value);
  #endif
  void set_latest_firmware_published_timestamp(const char* value);
  void set_latest_firmware_published_timestamp(const char* value, size_t size);
  ::std::string* mutable_latest_firmware_published_timestamp();
  ::std::string* release_latest_firmware_published_timestamp();
  void set_allocated_latest_firmware_published_timestamp(::std::string* latest_firmware_published_timestamp);

  // .logi.proto.Product product = 1;
  bool has_product() const;
  void clear_product();
  static const int kProductFieldNumber = 1;
  private:
  const ::logi::proto::Product& _internal_product() const;
  public:
  const ::logi::proto::Product& product() const;
  ::logi::proto::Product* release_product();
  ::logi::proto::Product* mutable_product();
  void set_allocated_product(::logi::proto::Product* product);

  // .logi.proto.LRProductUpdateSnapshot update_status = 6;
  bool has_update_status() const;
  void clear_update_status();
  static const int kUpdateStatusFieldNumber = 6;
  private:
  const ::logi::proto::LRProductUpdateSnapshot& _internal_update_status() const;
  public:
  const ::logi::proto::LRProductUpdateSnapshot& update_status() const;
  ::logi::proto::LRProductUpdateSnapshot* release_update_status();
  ::logi::proto::LRProductUpdateSnapshot* mutable_update_status();
  void set_allocated_update_status(::logi::proto::LRProductUpdateSnapshot* update_status);

  // @@protoc_insertion_point(class_scope:logi.proto.LRProductSnapshot)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      LRProductSnapshot_ExpectedDeviceCountEntry_DoNotUse,
      ::google::protobuf::uint32, ::google::protobuf::uint32,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      0 > expected_device_count_;
  ::google::protobuf::internal::MapField<
      LRProductSnapshot_ActualDeviceCountEntry_DoNotUse,
      ::google::protobuf::uint32, ::google::protobuf::uint32,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      0 > actual_device_count_;
  ::google::protobuf::internal::ArenaStringPtr latest_firmware_;
  ::google::protobuf::internal::ArenaStringPtr latest_firmware_published_timestamp_;
  ::logi::proto::Product* product_;
  ::logi::proto::LRProductUpdateSnapshot* update_status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cloud_5fdevice_5fstructures_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LRProductUpdateSnapshot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.LRProductUpdateSnapshot) */ {
 public:
  LRProductUpdateSnapshot();
  virtual ~LRProductUpdateSnapshot();

  LRProductUpdateSnapshot(const LRProductUpdateSnapshot& from);

  inline LRProductUpdateSnapshot& operator=(const LRProductUpdateSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LRProductUpdateSnapshot(LRProductUpdateSnapshot&& from) noexcept
    : LRProductUpdateSnapshot() {
    *this = ::std::move(from);
  }

  inline LRProductUpdateSnapshot& operator=(LRProductUpdateSnapshot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LRProductUpdateSnapshot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LRProductUpdateSnapshot* internal_default_instance() {
    return reinterpret_cast<const LRProductUpdateSnapshot*>(
               &_LRProductUpdateSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(LRProductUpdateSnapshot* other);
  friend void swap(LRProductUpdateSnapshot& a, LRProductUpdateSnapshot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LRProductUpdateSnapshot* New() const final {
    return CreateMaybeMessage<LRProductUpdateSnapshot>(NULL);
  }

  LRProductUpdateSnapshot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LRProductUpdateSnapshot>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LRProductUpdateSnapshot& from);
  void MergeFrom(const LRProductUpdateSnapshot& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LRProductUpdateSnapshot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float percentage_progress = 1;
  void clear_percentage_progress();
  static const int kPercentageProgressFieldNumber = 1;
  float percentage_progress() const;
  void set_percentage_progress(float value);

  // uint32 time_remaining_seconds = 2;
  void clear_time_remaining_seconds();
  static const int kTimeRemainingSecondsFieldNumber = 2;
  ::google::protobuf::uint32 time_remaining_seconds() const;
  void set_time_remaining_seconds(::google::protobuf::uint32 value);

  // uint32 error_code = 3;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 3;
  ::google::protobuf::uint32 error_code() const;
  void set_error_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:logi.proto.LRProductUpdateSnapshot)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float percentage_progress_;
  ::google::protobuf::uint32 time_remaining_seconds_;
  ::google::protobuf::uint32 error_code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cloud_5fdevice_5fstructures_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LRProductSnapshot

// .logi.proto.Product product = 1;
inline bool LRProductSnapshot::has_product() const {
  return this != internal_default_instance() && product_ != NULL;
}
inline const ::logi::proto::Product& LRProductSnapshot::_internal_product() const {
  return *product_;
}
inline const ::logi::proto::Product& LRProductSnapshot::product() const {
  const ::logi::proto::Product* p = product_;
  // @@protoc_insertion_point(field_get:logi.proto.LRProductSnapshot.product)
  return p != NULL ? *p : *reinterpret_cast<const ::logi::proto::Product*>(
      &::logi::proto::_Product_default_instance_);
}
inline ::logi::proto::Product* LRProductSnapshot::release_product() {
  // @@protoc_insertion_point(field_release:logi.proto.LRProductSnapshot.product)
  
  ::logi::proto::Product* temp = product_;
  product_ = NULL;
  return temp;
}
inline ::logi::proto::Product* LRProductSnapshot::mutable_product() {
  
  if (product_ == NULL) {
    auto* p = CreateMaybeMessage<::logi::proto::Product>(GetArenaNoVirtual());
    product_ = p;
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LRProductSnapshot.product)
  return product_;
}
inline void LRProductSnapshot::set_allocated_product(::logi::proto::Product* product) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(product_);
  }
  if (product) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      product = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, product, submessage_arena);
    }
    
  } else {
    
  }
  product_ = product;
  // @@protoc_insertion_point(field_set_allocated:logi.proto.LRProductSnapshot.product)
}

// map<uint32, uint32> expected_device_count = 2;
inline int LRProductSnapshot::expected_device_count_size() const {
  return expected_device_count_.size();
}
inline void LRProductSnapshot::clear_expected_device_count() {
  expected_device_count_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint32, ::google::protobuf::uint32 >&
LRProductSnapshot::expected_device_count() const {
  // @@protoc_insertion_point(field_map:logi.proto.LRProductSnapshot.expected_device_count)
  return expected_device_count_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint32, ::google::protobuf::uint32 >*
LRProductSnapshot::mutable_expected_device_count() {
  // @@protoc_insertion_point(field_mutable_map:logi.proto.LRProductSnapshot.expected_device_count)
  return expected_device_count_.MutableMap();
}

// map<uint32, uint32> actual_device_count = 3;
inline int LRProductSnapshot::actual_device_count_size() const {
  return actual_device_count_.size();
}
inline void LRProductSnapshot::clear_actual_device_count() {
  actual_device_count_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint32, ::google::protobuf::uint32 >&
LRProductSnapshot::actual_device_count() const {
  // @@protoc_insertion_point(field_map:logi.proto.LRProductSnapshot.actual_device_count)
  return actual_device_count_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint32, ::google::protobuf::uint32 >*
LRProductSnapshot::mutable_actual_device_count() {
  // @@protoc_insertion_point(field_mutable_map:logi.proto.LRProductSnapshot.actual_device_count)
  return actual_device_count_.MutableMap();
}

// string latest_firmware = 4;
inline void LRProductSnapshot::clear_latest_firmware() {
  latest_firmware_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LRProductSnapshot::latest_firmware() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRProductSnapshot.latest_firmware)
  return latest_firmware_.GetNoArena();
}
inline void LRProductSnapshot::set_latest_firmware(const ::std::string& value) {
  
  latest_firmware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logi.proto.LRProductSnapshot.latest_firmware)
}
#if LANG_CXX11
inline void LRProductSnapshot::set_latest_firmware(::std::string&& value) {
  
  latest_firmware_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:logi.proto.LRProductSnapshot.latest_firmware)
}
#endif
inline void LRProductSnapshot::set_latest_firmware(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  latest_firmware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logi.proto.LRProductSnapshot.latest_firmware)
}
inline void LRProductSnapshot::set_latest_firmware(const char* value, size_t size) {
  
  latest_firmware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logi.proto.LRProductSnapshot.latest_firmware)
}
inline ::std::string* LRProductSnapshot::mutable_latest_firmware() {
  
  // @@protoc_insertion_point(field_mutable:logi.proto.LRProductSnapshot.latest_firmware)
  return latest_firmware_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LRProductSnapshot::release_latest_firmware() {
  // @@protoc_insertion_point(field_release:logi.proto.LRProductSnapshot.latest_firmware)
  
  return latest_firmware_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LRProductSnapshot::set_allocated_latest_firmware(::std::string* latest_firmware) {
  if (latest_firmware != NULL) {
    
  } else {
    
  }
  latest_firmware_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), latest_firmware);
  // @@protoc_insertion_point(field_set_allocated:logi.proto.LRProductSnapshot.latest_firmware)
}

// string latest_firmware_published_timestamp = 5;
inline void LRProductSnapshot::clear_latest_firmware_published_timestamp() {
  latest_firmware_published_timestamp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LRProductSnapshot::latest_firmware_published_timestamp() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRProductSnapshot.latest_firmware_published_timestamp)
  return latest_firmware_published_timestamp_.GetNoArena();
}
inline void LRProductSnapshot::set_latest_firmware_published_timestamp(const ::std::string& value) {
  
  latest_firmware_published_timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logi.proto.LRProductSnapshot.latest_firmware_published_timestamp)
}
#if LANG_CXX11
inline void LRProductSnapshot::set_latest_firmware_published_timestamp(::std::string&& value) {
  
  latest_firmware_published_timestamp_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:logi.proto.LRProductSnapshot.latest_firmware_published_timestamp)
}
#endif
inline void LRProductSnapshot::set_latest_firmware_published_timestamp(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  latest_firmware_published_timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logi.proto.LRProductSnapshot.latest_firmware_published_timestamp)
}
inline void LRProductSnapshot::set_latest_firmware_published_timestamp(const char* value, size_t size) {
  
  latest_firmware_published_timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logi.proto.LRProductSnapshot.latest_firmware_published_timestamp)
}
inline ::std::string* LRProductSnapshot::mutable_latest_firmware_published_timestamp() {
  
  // @@protoc_insertion_point(field_mutable:logi.proto.LRProductSnapshot.latest_firmware_published_timestamp)
  return latest_firmware_published_timestamp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LRProductSnapshot::release_latest_firmware_published_timestamp() {
  // @@protoc_insertion_point(field_release:logi.proto.LRProductSnapshot.latest_firmware_published_timestamp)
  
  return latest_firmware_published_timestamp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LRProductSnapshot::set_allocated_latest_firmware_published_timestamp(::std::string* latest_firmware_published_timestamp) {
  if (latest_firmware_published_timestamp != NULL) {
    
  } else {
    
  }
  latest_firmware_published_timestamp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), latest_firmware_published_timestamp);
  // @@protoc_insertion_point(field_set_allocated:logi.proto.LRProductSnapshot.latest_firmware_published_timestamp)
}

// .logi.proto.LRProductUpdateSnapshot update_status = 6;
inline bool LRProductSnapshot::has_update_status() const {
  return this != internal_default_instance() && update_status_ != NULL;
}
inline void LRProductSnapshot::clear_update_status() {
  if (GetArenaNoVirtual() == NULL && update_status_ != NULL) {
    delete update_status_;
  }
  update_status_ = NULL;
}
inline const ::logi::proto::LRProductUpdateSnapshot& LRProductSnapshot::_internal_update_status() const {
  return *update_status_;
}
inline const ::logi::proto::LRProductUpdateSnapshot& LRProductSnapshot::update_status() const {
  const ::logi::proto::LRProductUpdateSnapshot* p = update_status_;
  // @@protoc_insertion_point(field_get:logi.proto.LRProductSnapshot.update_status)
  return p != NULL ? *p : *reinterpret_cast<const ::logi::proto::LRProductUpdateSnapshot*>(
      &::logi::proto::_LRProductUpdateSnapshot_default_instance_);
}
inline ::logi::proto::LRProductUpdateSnapshot* LRProductSnapshot::release_update_status() {
  // @@protoc_insertion_point(field_release:logi.proto.LRProductSnapshot.update_status)
  
  ::logi::proto::LRProductUpdateSnapshot* temp = update_status_;
  update_status_ = NULL;
  return temp;
}
inline ::logi::proto::LRProductUpdateSnapshot* LRProductSnapshot::mutable_update_status() {
  
  if (update_status_ == NULL) {
    auto* p = CreateMaybeMessage<::logi::proto::LRProductUpdateSnapshot>(GetArenaNoVirtual());
    update_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LRProductSnapshot.update_status)
  return update_status_;
}
inline void LRProductSnapshot::set_allocated_update_status(::logi::proto::LRProductUpdateSnapshot* update_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete update_status_;
  }
  if (update_status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      update_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update_status, submessage_arena);
    }
    
  } else {
    
  }
  update_status_ = update_status;
  // @@protoc_insertion_point(field_set_allocated:logi.proto.LRProductSnapshot.update_status)
}

// -------------------------------------------------------------------

// LRProductUpdateSnapshot

// float percentage_progress = 1;
inline void LRProductUpdateSnapshot::clear_percentage_progress() {
  percentage_progress_ = 0;
}
inline float LRProductUpdateSnapshot::percentage_progress() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRProductUpdateSnapshot.percentage_progress)
  return percentage_progress_;
}
inline void LRProductUpdateSnapshot::set_percentage_progress(float value) {
  
  percentage_progress_ = value;
  // @@protoc_insertion_point(field_set:logi.proto.LRProductUpdateSnapshot.percentage_progress)
}

// uint32 time_remaining_seconds = 2;
inline void LRProductUpdateSnapshot::clear_time_remaining_seconds() {
  time_remaining_seconds_ = 0u;
}
inline ::google::protobuf::uint32 LRProductUpdateSnapshot::time_remaining_seconds() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRProductUpdateSnapshot.time_remaining_seconds)
  return time_remaining_seconds_;
}
inline void LRProductUpdateSnapshot::set_time_remaining_seconds(::google::protobuf::uint32 value) {
  
  time_remaining_seconds_ = value;
  // @@protoc_insertion_point(field_set:logi.proto.LRProductUpdateSnapshot.time_remaining_seconds)
}

// uint32 error_code = 3;
inline void LRProductUpdateSnapshot::clear_error_code() {
  error_code_ = 0u;
}
inline ::google::protobuf::uint32 LRProductUpdateSnapshot::error_code() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRProductUpdateSnapshot.error_code)
  return error_code_;
}
inline void LRProductUpdateSnapshot::set_error_code(::google::protobuf::uint32 value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:logi.proto.LRProductUpdateSnapshot.error_code)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace logi

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_cloud_5fdevice_5fstructures_2eproto
