// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cloud_provisioning_requests.proto

#ifndef PROTOBUF_INCLUDED_cloud_5fprovisioning_5frequests_2eproto
#define PROTOBUF_INCLUDED_cloud_5fprovisioning_5frequests_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "cloud_provisioning_structures.pb.h"
#include "common.pb.h"
#include "configuration_structures.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_cloud_5fprovisioning_5frequests_2eproto 

namespace protobuf_cloud_5fprovisioning_5frequests_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_cloud_5fprovisioning_5frequests_2eproto
namespace logi {
namespace proto {
class LRDeprovisionHostRequest;
class LRDeprovisionHostRequestDefaultTypeInternal;
extern LRDeprovisionHostRequestDefaultTypeInternal _LRDeprovisionHostRequest_default_instance_;
class LRDeprovisionHostResponse;
class LRDeprovisionHostResponseDefaultTypeInternal;
extern LRDeprovisionHostResponseDefaultTypeInternal _LRDeprovisionHostResponse_default_instance_;
class LRGetProvisioningDataRequest;
class LRGetProvisioningDataRequestDefaultTypeInternal;
extern LRGetProvisioningDataRequestDefaultTypeInternal _LRGetProvisioningDataRequest_default_instance_;
class LRGetProvisioningDataResponse;
class LRGetProvisioningDataResponseDefaultTypeInternal;
extern LRGetProvisioningDataResponseDefaultTypeInternal _LRGetProvisioningDataResponse_default_instance_;
class LRProvisionHostRequest;
class LRProvisionHostRequestDefaultTypeInternal;
extern LRProvisionHostRequestDefaultTypeInternal _LRProvisionHostRequest_default_instance_;
class LRProvisionHostResponse;
class LRProvisionHostResponseDefaultTypeInternal;
extern LRProvisionHostResponseDefaultTypeInternal _LRProvisionHostResponse_default_instance_;
class LRSetCloudConnectionStateRequest;
class LRSetCloudConnectionStateRequestDefaultTypeInternal;
extern LRSetCloudConnectionStateRequestDefaultTypeInternal _LRSetCloudConnectionStateRequest_default_instance_;
class LRSetCloudConnectionStateResponse;
class LRSetCloudConnectionStateResponseDefaultTypeInternal;
extern LRSetCloudConnectionStateResponseDefaultTypeInternal _LRSetCloudConnectionStateResponse_default_instance_;
}  // namespace proto
}  // namespace logi
namespace google {
namespace protobuf {
template<> ::logi::proto::LRDeprovisionHostRequest* Arena::CreateMaybeMessage<::logi::proto::LRDeprovisionHostRequest>(Arena*);
template<> ::logi::proto::LRDeprovisionHostResponse* Arena::CreateMaybeMessage<::logi::proto::LRDeprovisionHostResponse>(Arena*);
template<> ::logi::proto::LRGetProvisioningDataRequest* Arena::CreateMaybeMessage<::logi::proto::LRGetProvisioningDataRequest>(Arena*);
template<> ::logi::proto::LRGetProvisioningDataResponse* Arena::CreateMaybeMessage<::logi::proto::LRGetProvisioningDataResponse>(Arena*);
template<> ::logi::proto::LRProvisionHostRequest* Arena::CreateMaybeMessage<::logi::proto::LRProvisionHostRequest>(Arena*);
template<> ::logi::proto::LRProvisionHostResponse* Arena::CreateMaybeMessage<::logi::proto::LRProvisionHostResponse>(Arena*);
template<> ::logi::proto::LRSetCloudConnectionStateRequest* Arena::CreateMaybeMessage<::logi::proto::LRSetCloudConnectionStateRequest>(Arena*);
template<> ::logi::proto::LRSetCloudConnectionStateResponse* Arena::CreateMaybeMessage<::logi::proto::LRSetCloudConnectionStateResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace logi {
namespace proto {

// ===================================================================

class LRProvisionHostRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.LRProvisionHostRequest) */ {
 public:
  LRProvisionHostRequest();
  virtual ~LRProvisionHostRequest();

  LRProvisionHostRequest(const LRProvisionHostRequest& from);

  inline LRProvisionHostRequest& operator=(const LRProvisionHostRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LRProvisionHostRequest(LRProvisionHostRequest&& from) noexcept
    : LRProvisionHostRequest() {
    *this = ::std::move(from);
  }

  inline LRProvisionHostRequest& operator=(LRProvisionHostRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LRProvisionHostRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LRProvisionHostRequest* internal_default_instance() {
    return reinterpret_cast<const LRProvisionHostRequest*>(
               &_LRProvisionHostRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LRProvisionHostRequest* other);
  friend void swap(LRProvisionHostRequest& a, LRProvisionHostRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LRProvisionHostRequest* New() const final {
    return CreateMaybeMessage<LRProvisionHostRequest>(NULL);
  }

  LRProvisionHostRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LRProvisionHostRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LRProvisionHostRequest& from);
  void MergeFrom(const LRProvisionHostRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LRProvisionHostRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .logi.proto.LRProvisioningData provisioning_data = 1;
  bool has_provisioning_data() const;
  void clear_provisioning_data();
  static const int kProvisioningDataFieldNumber = 1;
  private:
  const ::logi::proto::LRProvisioningData& _internal_provisioning_data() const;
  public:
  const ::logi::proto::LRProvisioningData& provisioning_data() const;
  ::logi::proto::LRProvisioningData* release_provisioning_data();
  ::logi::proto::LRProvisioningData* mutable_provisioning_data();
  void set_allocated_provisioning_data(::logi::proto::LRProvisioningData* provisioning_data);

  // @@protoc_insertion_point(class_scope:logi.proto.LRProvisionHostRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::logi::proto::LRProvisioningData* provisioning_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cloud_5fprovisioning_5frequests_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LRProvisionHostResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.LRProvisionHostResponse) */ {
 public:
  LRProvisionHostResponse();
  virtual ~LRProvisionHostResponse();

  LRProvisionHostResponse(const LRProvisionHostResponse& from);

  inline LRProvisionHostResponse& operator=(const LRProvisionHostResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LRProvisionHostResponse(LRProvisionHostResponse&& from) noexcept
    : LRProvisionHostResponse() {
    *this = ::std::move(from);
  }

  inline LRProvisionHostResponse& operator=(LRProvisionHostResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LRProvisionHostResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LRProvisionHostResponse* internal_default_instance() {
    return reinterpret_cast<const LRProvisionHostResponse*>(
               &_LRProvisionHostResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(LRProvisionHostResponse* other);
  friend void swap(LRProvisionHostResponse& a, LRProvisionHostResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LRProvisionHostResponse* New() const final {
    return CreateMaybeMessage<LRProvisionHostResponse>(NULL);
  }

  LRProvisionHostResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LRProvisionHostResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LRProvisionHostResponse& from);
  void MergeFrom(const LRProvisionHostResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LRProvisionHostResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .logi.proto.Error errors = 1;
  int errors_size() const;
  void clear_errors();
  static const int kErrorsFieldNumber = 1;
  ::logi::proto::Error* mutable_errors(int index);
  ::google::protobuf::RepeatedPtrField< ::logi::proto::Error >*
      mutable_errors();
  const ::logi::proto::Error& errors(int index) const;
  ::logi::proto::Error* add_errors();
  const ::google::protobuf::RepeatedPtrField< ::logi::proto::Error >&
      errors() const;

  // bool success = 2;
  void clear_success();
  static const int kSuccessFieldNumber = 2;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:logi.proto.LRProvisionHostResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::logi::proto::Error > errors_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cloud_5fprovisioning_5frequests_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LRDeprovisionHostRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.LRDeprovisionHostRequest) */ {
 public:
  LRDeprovisionHostRequest();
  virtual ~LRDeprovisionHostRequest();

  LRDeprovisionHostRequest(const LRDeprovisionHostRequest& from);

  inline LRDeprovisionHostRequest& operator=(const LRDeprovisionHostRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LRDeprovisionHostRequest(LRDeprovisionHostRequest&& from) noexcept
    : LRDeprovisionHostRequest() {
    *this = ::std::move(from);
  }

  inline LRDeprovisionHostRequest& operator=(LRDeprovisionHostRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LRDeprovisionHostRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LRDeprovisionHostRequest* internal_default_instance() {
    return reinterpret_cast<const LRDeprovisionHostRequest*>(
               &_LRDeprovisionHostRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LRDeprovisionHostRequest* other);
  friend void swap(LRDeprovisionHostRequest& a, LRDeprovisionHostRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LRDeprovisionHostRequest* New() const final {
    return CreateMaybeMessage<LRDeprovisionHostRequest>(NULL);
  }

  LRDeprovisionHostRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LRDeprovisionHostRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LRDeprovisionHostRequest& from);
  void MergeFrom(const LRDeprovisionHostRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LRDeprovisionHostRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool reserved = 1;
  void clear_reserved();
  static const int kReservedFieldNumber = 1;
  bool reserved() const;
  void set_reserved(bool value);

  // @@protoc_insertion_point(class_scope:logi.proto.LRDeprovisionHostRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool reserved_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cloud_5fprovisioning_5frequests_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LRDeprovisionHostResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.LRDeprovisionHostResponse) */ {
 public:
  LRDeprovisionHostResponse();
  virtual ~LRDeprovisionHostResponse();

  LRDeprovisionHostResponse(const LRDeprovisionHostResponse& from);

  inline LRDeprovisionHostResponse& operator=(const LRDeprovisionHostResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LRDeprovisionHostResponse(LRDeprovisionHostResponse&& from) noexcept
    : LRDeprovisionHostResponse() {
    *this = ::std::move(from);
  }

  inline LRDeprovisionHostResponse& operator=(LRDeprovisionHostResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LRDeprovisionHostResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LRDeprovisionHostResponse* internal_default_instance() {
    return reinterpret_cast<const LRDeprovisionHostResponse*>(
               &_LRDeprovisionHostResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(LRDeprovisionHostResponse* other);
  friend void swap(LRDeprovisionHostResponse& a, LRDeprovisionHostResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LRDeprovisionHostResponse* New() const final {
    return CreateMaybeMessage<LRDeprovisionHostResponse>(NULL);
  }

  LRDeprovisionHostResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LRDeprovisionHostResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LRDeprovisionHostResponse& from);
  void MergeFrom(const LRDeprovisionHostResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LRDeprovisionHostResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .logi.proto.Error errors = 1;
  int errors_size() const;
  void clear_errors();
  static const int kErrorsFieldNumber = 1;
  ::logi::proto::Error* mutable_errors(int index);
  ::google::protobuf::RepeatedPtrField< ::logi::proto::Error >*
      mutable_errors();
  const ::logi::proto::Error& errors(int index) const;
  ::logi::proto::Error* add_errors();
  const ::google::protobuf::RepeatedPtrField< ::logi::proto::Error >&
      errors() const;

  // bool success = 2;
  void clear_success();
  static const int kSuccessFieldNumber = 2;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:logi.proto.LRDeprovisionHostResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::logi::proto::Error > errors_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cloud_5fprovisioning_5frequests_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LRGetProvisioningDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.LRGetProvisioningDataRequest) */ {
 public:
  LRGetProvisioningDataRequest();
  virtual ~LRGetProvisioningDataRequest();

  LRGetProvisioningDataRequest(const LRGetProvisioningDataRequest& from);

  inline LRGetProvisioningDataRequest& operator=(const LRGetProvisioningDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LRGetProvisioningDataRequest(LRGetProvisioningDataRequest&& from) noexcept
    : LRGetProvisioningDataRequest() {
    *this = ::std::move(from);
  }

  inline LRGetProvisioningDataRequest& operator=(LRGetProvisioningDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LRGetProvisioningDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LRGetProvisioningDataRequest* internal_default_instance() {
    return reinterpret_cast<const LRGetProvisioningDataRequest*>(
               &_LRGetProvisioningDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(LRGetProvisioningDataRequest* other);
  friend void swap(LRGetProvisioningDataRequest& a, LRGetProvisioningDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LRGetProvisioningDataRequest* New() const final {
    return CreateMaybeMessage<LRGetProvisioningDataRequest>(NULL);
  }

  LRGetProvisioningDataRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LRGetProvisioningDataRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LRGetProvisioningDataRequest& from);
  void MergeFrom(const LRGetProvisioningDataRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LRGetProvisioningDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool reserved = 1;
  void clear_reserved();
  static const int kReservedFieldNumber = 1;
  bool reserved() const;
  void set_reserved(bool value);

  // @@protoc_insertion_point(class_scope:logi.proto.LRGetProvisioningDataRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool reserved_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cloud_5fprovisioning_5frequests_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LRGetProvisioningDataResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.LRGetProvisioningDataResponse) */ {
 public:
  LRGetProvisioningDataResponse();
  virtual ~LRGetProvisioningDataResponse();

  LRGetProvisioningDataResponse(const LRGetProvisioningDataResponse& from);

  inline LRGetProvisioningDataResponse& operator=(const LRGetProvisioningDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LRGetProvisioningDataResponse(LRGetProvisioningDataResponse&& from) noexcept
    : LRGetProvisioningDataResponse() {
    *this = ::std::move(from);
  }

  inline LRGetProvisioningDataResponse& operator=(LRGetProvisioningDataResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LRGetProvisioningDataResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LRGetProvisioningDataResponse* internal_default_instance() {
    return reinterpret_cast<const LRGetProvisioningDataResponse*>(
               &_LRGetProvisioningDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(LRGetProvisioningDataResponse* other);
  friend void swap(LRGetProvisioningDataResponse& a, LRGetProvisioningDataResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LRGetProvisioningDataResponse* New() const final {
    return CreateMaybeMessage<LRGetProvisioningDataResponse>(NULL);
  }

  LRGetProvisioningDataResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LRGetProvisioningDataResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LRGetProvisioningDataResponse& from);
  void MergeFrom(const LRGetProvisioningDataResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LRGetProvisioningDataResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .logi.proto.Error errors = 1;
  int errors_size() const;
  void clear_errors();
  static const int kErrorsFieldNumber = 1;
  ::logi::proto::Error* mutable_errors(int index);
  ::google::protobuf::RepeatedPtrField< ::logi::proto::Error >*
      mutable_errors();
  const ::logi::proto::Error& errors(int index) const;
  ::logi::proto::Error* add_errors();
  const ::google::protobuf::RepeatedPtrField< ::logi::proto::Error >&
      errors() const;

  // .logi.proto.LRProvisioningData provisioning_data = 4;
  bool has_provisioning_data() const;
  void clear_provisioning_data();
  static const int kProvisioningDataFieldNumber = 4;
  private:
  const ::logi::proto::LRProvisioningData& _internal_provisioning_data() const;
  public:
  const ::logi::proto::LRProvisioningData& provisioning_data() const;
  ::logi::proto::LRProvisioningData* release_provisioning_data();
  ::logi::proto::LRProvisioningData* mutable_provisioning_data();
  void set_allocated_provisioning_data(::logi::proto::LRProvisioningData* provisioning_data);

  // bool is_provisioned = 2;
  void clear_is_provisioned();
  static const int kIsProvisionedFieldNumber = 2;
  bool is_provisioned() const;
  void set_is_provisioned(bool value);

  // bool is_connected_to_cloud = 3;
  void clear_is_connected_to_cloud();
  static const int kIsConnectedToCloudFieldNumber = 3;
  bool is_connected_to_cloud() const;
  void set_is_connected_to_cloud(bool value);

  // @@protoc_insertion_point(class_scope:logi.proto.LRGetProvisioningDataResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::logi::proto::Error > errors_;
  ::logi::proto::LRProvisioningData* provisioning_data_;
  bool is_provisioned_;
  bool is_connected_to_cloud_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cloud_5fprovisioning_5frequests_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LRSetCloudConnectionStateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.LRSetCloudConnectionStateRequest) */ {
 public:
  LRSetCloudConnectionStateRequest();
  virtual ~LRSetCloudConnectionStateRequest();

  LRSetCloudConnectionStateRequest(const LRSetCloudConnectionStateRequest& from);

  inline LRSetCloudConnectionStateRequest& operator=(const LRSetCloudConnectionStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LRSetCloudConnectionStateRequest(LRSetCloudConnectionStateRequest&& from) noexcept
    : LRSetCloudConnectionStateRequest() {
    *this = ::std::move(from);
  }

  inline LRSetCloudConnectionStateRequest& operator=(LRSetCloudConnectionStateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LRSetCloudConnectionStateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LRSetCloudConnectionStateRequest* internal_default_instance() {
    return reinterpret_cast<const LRSetCloudConnectionStateRequest*>(
               &_LRSetCloudConnectionStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(LRSetCloudConnectionStateRequest* other);
  friend void swap(LRSetCloudConnectionStateRequest& a, LRSetCloudConnectionStateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LRSetCloudConnectionStateRequest* New() const final {
    return CreateMaybeMessage<LRSetCloudConnectionStateRequest>(NULL);
  }

  LRSetCloudConnectionStateRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LRSetCloudConnectionStateRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LRSetCloudConnectionStateRequest& from);
  void MergeFrom(const LRSetCloudConnectionStateRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LRSetCloudConnectionStateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool is_connected_to_cloud = 1;
  void clear_is_connected_to_cloud();
  static const int kIsConnectedToCloudFieldNumber = 1;
  bool is_connected_to_cloud() const;
  void set_is_connected_to_cloud(bool value);

  // @@protoc_insertion_point(class_scope:logi.proto.LRSetCloudConnectionStateRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool is_connected_to_cloud_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cloud_5fprovisioning_5frequests_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LRSetCloudConnectionStateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.LRSetCloudConnectionStateResponse) */ {
 public:
  LRSetCloudConnectionStateResponse();
  virtual ~LRSetCloudConnectionStateResponse();

  LRSetCloudConnectionStateResponse(const LRSetCloudConnectionStateResponse& from);

  inline LRSetCloudConnectionStateResponse& operator=(const LRSetCloudConnectionStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LRSetCloudConnectionStateResponse(LRSetCloudConnectionStateResponse&& from) noexcept
    : LRSetCloudConnectionStateResponse() {
    *this = ::std::move(from);
  }

  inline LRSetCloudConnectionStateResponse& operator=(LRSetCloudConnectionStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LRSetCloudConnectionStateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LRSetCloudConnectionStateResponse* internal_default_instance() {
    return reinterpret_cast<const LRSetCloudConnectionStateResponse*>(
               &_LRSetCloudConnectionStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(LRSetCloudConnectionStateResponse* other);
  friend void swap(LRSetCloudConnectionStateResponse& a, LRSetCloudConnectionStateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LRSetCloudConnectionStateResponse* New() const final {
    return CreateMaybeMessage<LRSetCloudConnectionStateResponse>(NULL);
  }

  LRSetCloudConnectionStateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LRSetCloudConnectionStateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LRSetCloudConnectionStateResponse& from);
  void MergeFrom(const LRSetCloudConnectionStateResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LRSetCloudConnectionStateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .logi.proto.Error errors = 1;
  int errors_size() const;
  void clear_errors();
  static const int kErrorsFieldNumber = 1;
  ::logi::proto::Error* mutable_errors(int index);
  ::google::protobuf::RepeatedPtrField< ::logi::proto::Error >*
      mutable_errors();
  const ::logi::proto::Error& errors(int index) const;
  ::logi::proto::Error* add_errors();
  const ::google::protobuf::RepeatedPtrField< ::logi::proto::Error >&
      errors() const;

  // .logi.proto.HostInformation host_information = 2;
  bool has_host_information() const;
  void clear_host_information();
  static const int kHostInformationFieldNumber = 2;
  private:
  const ::logi::proto::HostInformation& _internal_host_information() const;
  public:
  const ::logi::proto::HostInformation& host_information() const;
  ::logi::proto::HostInformation* release_host_information();
  ::logi::proto::HostInformation* mutable_host_information();
  void set_allocated_host_information(::logi::proto::HostInformation* host_information);

  // @@protoc_insertion_point(class_scope:logi.proto.LRSetCloudConnectionStateResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::logi::proto::Error > errors_;
  ::logi::proto::HostInformation* host_information_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_cloud_5fprovisioning_5frequests_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LRProvisionHostRequest

// .logi.proto.LRProvisioningData provisioning_data = 1;
inline bool LRProvisionHostRequest::has_provisioning_data() const {
  return this != internal_default_instance() && provisioning_data_ != NULL;
}
inline const ::logi::proto::LRProvisioningData& LRProvisionHostRequest::_internal_provisioning_data() const {
  return *provisioning_data_;
}
inline const ::logi::proto::LRProvisioningData& LRProvisionHostRequest::provisioning_data() const {
  const ::logi::proto::LRProvisioningData* p = provisioning_data_;
  // @@protoc_insertion_point(field_get:logi.proto.LRProvisionHostRequest.provisioning_data)
  return p != NULL ? *p : *reinterpret_cast<const ::logi::proto::LRProvisioningData*>(
      &::logi::proto::_LRProvisioningData_default_instance_);
}
inline ::logi::proto::LRProvisioningData* LRProvisionHostRequest::release_provisioning_data() {
  // @@protoc_insertion_point(field_release:logi.proto.LRProvisionHostRequest.provisioning_data)
  
  ::logi::proto::LRProvisioningData* temp = provisioning_data_;
  provisioning_data_ = NULL;
  return temp;
}
inline ::logi::proto::LRProvisioningData* LRProvisionHostRequest::mutable_provisioning_data() {
  
  if (provisioning_data_ == NULL) {
    auto* p = CreateMaybeMessage<::logi::proto::LRProvisioningData>(GetArenaNoVirtual());
    provisioning_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LRProvisionHostRequest.provisioning_data)
  return provisioning_data_;
}
inline void LRProvisionHostRequest::set_allocated_provisioning_data(::logi::proto::LRProvisioningData* provisioning_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(provisioning_data_);
  }
  if (provisioning_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      provisioning_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, provisioning_data, submessage_arena);
    }
    
  } else {
    
  }
  provisioning_data_ = provisioning_data;
  // @@protoc_insertion_point(field_set_allocated:logi.proto.LRProvisionHostRequest.provisioning_data)
}

// -------------------------------------------------------------------

// LRProvisionHostResponse

// repeated .logi.proto.Error errors = 1;
inline int LRProvisionHostResponse::errors_size() const {
  return errors_.size();
}
inline ::logi::proto::Error* LRProvisionHostResponse::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:logi.proto.LRProvisionHostResponse.errors)
  return errors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::logi::proto::Error >*
LRProvisionHostResponse::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:logi.proto.LRProvisionHostResponse.errors)
  return &errors_;
}
inline const ::logi::proto::Error& LRProvisionHostResponse::errors(int index) const {
  // @@protoc_insertion_point(field_get:logi.proto.LRProvisionHostResponse.errors)
  return errors_.Get(index);
}
inline ::logi::proto::Error* LRProvisionHostResponse::add_errors() {
  // @@protoc_insertion_point(field_add:logi.proto.LRProvisionHostResponse.errors)
  return errors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::logi::proto::Error >&
LRProvisionHostResponse::errors() const {
  // @@protoc_insertion_point(field_list:logi.proto.LRProvisionHostResponse.errors)
  return errors_;
}

// bool success = 2;
inline void LRProvisionHostResponse::clear_success() {
  success_ = false;
}
inline bool LRProvisionHostResponse::success() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRProvisionHostResponse.success)
  return success_;
}
inline void LRProvisionHostResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:logi.proto.LRProvisionHostResponse.success)
}

// -------------------------------------------------------------------

// LRDeprovisionHostRequest

// bool reserved = 1;
inline void LRDeprovisionHostRequest::clear_reserved() {
  reserved_ = false;
}
inline bool LRDeprovisionHostRequest::reserved() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRDeprovisionHostRequest.reserved)
  return reserved_;
}
inline void LRDeprovisionHostRequest::set_reserved(bool value) {
  
  reserved_ = value;
  // @@protoc_insertion_point(field_set:logi.proto.LRDeprovisionHostRequest.reserved)
}

// -------------------------------------------------------------------

// LRDeprovisionHostResponse

// repeated .logi.proto.Error errors = 1;
inline int LRDeprovisionHostResponse::errors_size() const {
  return errors_.size();
}
inline ::logi::proto::Error* LRDeprovisionHostResponse::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:logi.proto.LRDeprovisionHostResponse.errors)
  return errors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::logi::proto::Error >*
LRDeprovisionHostResponse::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:logi.proto.LRDeprovisionHostResponse.errors)
  return &errors_;
}
inline const ::logi::proto::Error& LRDeprovisionHostResponse::errors(int index) const {
  // @@protoc_insertion_point(field_get:logi.proto.LRDeprovisionHostResponse.errors)
  return errors_.Get(index);
}
inline ::logi::proto::Error* LRDeprovisionHostResponse::add_errors() {
  // @@protoc_insertion_point(field_add:logi.proto.LRDeprovisionHostResponse.errors)
  return errors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::logi::proto::Error >&
LRDeprovisionHostResponse::errors() const {
  // @@protoc_insertion_point(field_list:logi.proto.LRDeprovisionHostResponse.errors)
  return errors_;
}

// bool success = 2;
inline void LRDeprovisionHostResponse::clear_success() {
  success_ = false;
}
inline bool LRDeprovisionHostResponse::success() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRDeprovisionHostResponse.success)
  return success_;
}
inline void LRDeprovisionHostResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:logi.proto.LRDeprovisionHostResponse.success)
}

// -------------------------------------------------------------------

// LRGetProvisioningDataRequest

// bool reserved = 1;
inline void LRGetProvisioningDataRequest::clear_reserved() {
  reserved_ = false;
}
inline bool LRGetProvisioningDataRequest::reserved() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRGetProvisioningDataRequest.reserved)
  return reserved_;
}
inline void LRGetProvisioningDataRequest::set_reserved(bool value) {
  
  reserved_ = value;
  // @@protoc_insertion_point(field_set:logi.proto.LRGetProvisioningDataRequest.reserved)
}

// -------------------------------------------------------------------

// LRGetProvisioningDataResponse

// repeated .logi.proto.Error errors = 1;
inline int LRGetProvisioningDataResponse::errors_size() const {
  return errors_.size();
}
inline ::logi::proto::Error* LRGetProvisioningDataResponse::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:logi.proto.LRGetProvisioningDataResponse.errors)
  return errors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::logi::proto::Error >*
LRGetProvisioningDataResponse::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:logi.proto.LRGetProvisioningDataResponse.errors)
  return &errors_;
}
inline const ::logi::proto::Error& LRGetProvisioningDataResponse::errors(int index) const {
  // @@protoc_insertion_point(field_get:logi.proto.LRGetProvisioningDataResponse.errors)
  return errors_.Get(index);
}
inline ::logi::proto::Error* LRGetProvisioningDataResponse::add_errors() {
  // @@protoc_insertion_point(field_add:logi.proto.LRGetProvisioningDataResponse.errors)
  return errors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::logi::proto::Error >&
LRGetProvisioningDataResponse::errors() const {
  // @@protoc_insertion_point(field_list:logi.proto.LRGetProvisioningDataResponse.errors)
  return errors_;
}

// bool is_provisioned = 2;
inline void LRGetProvisioningDataResponse::clear_is_provisioned() {
  is_provisioned_ = false;
}
inline bool LRGetProvisioningDataResponse::is_provisioned() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRGetProvisioningDataResponse.is_provisioned)
  return is_provisioned_;
}
inline void LRGetProvisioningDataResponse::set_is_provisioned(bool value) {
  
  is_provisioned_ = value;
  // @@protoc_insertion_point(field_set:logi.proto.LRGetProvisioningDataResponse.is_provisioned)
}

// bool is_connected_to_cloud = 3;
inline void LRGetProvisioningDataResponse::clear_is_connected_to_cloud() {
  is_connected_to_cloud_ = false;
}
inline bool LRGetProvisioningDataResponse::is_connected_to_cloud() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRGetProvisioningDataResponse.is_connected_to_cloud)
  return is_connected_to_cloud_;
}
inline void LRGetProvisioningDataResponse::set_is_connected_to_cloud(bool value) {
  
  is_connected_to_cloud_ = value;
  // @@protoc_insertion_point(field_set:logi.proto.LRGetProvisioningDataResponse.is_connected_to_cloud)
}

// .logi.proto.LRProvisioningData provisioning_data = 4;
inline bool LRGetProvisioningDataResponse::has_provisioning_data() const {
  return this != internal_default_instance() && provisioning_data_ != NULL;
}
inline const ::logi::proto::LRProvisioningData& LRGetProvisioningDataResponse::_internal_provisioning_data() const {
  return *provisioning_data_;
}
inline const ::logi::proto::LRProvisioningData& LRGetProvisioningDataResponse::provisioning_data() const {
  const ::logi::proto::LRProvisioningData* p = provisioning_data_;
  // @@protoc_insertion_point(field_get:logi.proto.LRGetProvisioningDataResponse.provisioning_data)
  return p != NULL ? *p : *reinterpret_cast<const ::logi::proto::LRProvisioningData*>(
      &::logi::proto::_LRProvisioningData_default_instance_);
}
inline ::logi::proto::LRProvisioningData* LRGetProvisioningDataResponse::release_provisioning_data() {
  // @@protoc_insertion_point(field_release:logi.proto.LRGetProvisioningDataResponse.provisioning_data)
  
  ::logi::proto::LRProvisioningData* temp = provisioning_data_;
  provisioning_data_ = NULL;
  return temp;
}
inline ::logi::proto::LRProvisioningData* LRGetProvisioningDataResponse::mutable_provisioning_data() {
  
  if (provisioning_data_ == NULL) {
    auto* p = CreateMaybeMessage<::logi::proto::LRProvisioningData>(GetArenaNoVirtual());
    provisioning_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LRGetProvisioningDataResponse.provisioning_data)
  return provisioning_data_;
}
inline void LRGetProvisioningDataResponse::set_allocated_provisioning_data(::logi::proto::LRProvisioningData* provisioning_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(provisioning_data_);
  }
  if (provisioning_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      provisioning_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, provisioning_data, submessage_arena);
    }
    
  } else {
    
  }
  provisioning_data_ = provisioning_data;
  // @@protoc_insertion_point(field_set_allocated:logi.proto.LRGetProvisioningDataResponse.provisioning_data)
}

// -------------------------------------------------------------------

// LRSetCloudConnectionStateRequest

// bool is_connected_to_cloud = 1;
inline void LRSetCloudConnectionStateRequest::clear_is_connected_to_cloud() {
  is_connected_to_cloud_ = false;
}
inline bool LRSetCloudConnectionStateRequest::is_connected_to_cloud() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRSetCloudConnectionStateRequest.is_connected_to_cloud)
  return is_connected_to_cloud_;
}
inline void LRSetCloudConnectionStateRequest::set_is_connected_to_cloud(bool value) {
  
  is_connected_to_cloud_ = value;
  // @@protoc_insertion_point(field_set:logi.proto.LRSetCloudConnectionStateRequest.is_connected_to_cloud)
}

// -------------------------------------------------------------------

// LRSetCloudConnectionStateResponse

// repeated .logi.proto.Error errors = 1;
inline int LRSetCloudConnectionStateResponse::errors_size() const {
  return errors_.size();
}
inline ::logi::proto::Error* LRSetCloudConnectionStateResponse::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:logi.proto.LRSetCloudConnectionStateResponse.errors)
  return errors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::logi::proto::Error >*
LRSetCloudConnectionStateResponse::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:logi.proto.LRSetCloudConnectionStateResponse.errors)
  return &errors_;
}
inline const ::logi::proto::Error& LRSetCloudConnectionStateResponse::errors(int index) const {
  // @@protoc_insertion_point(field_get:logi.proto.LRSetCloudConnectionStateResponse.errors)
  return errors_.Get(index);
}
inline ::logi::proto::Error* LRSetCloudConnectionStateResponse::add_errors() {
  // @@protoc_insertion_point(field_add:logi.proto.LRSetCloudConnectionStateResponse.errors)
  return errors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::logi::proto::Error >&
LRSetCloudConnectionStateResponse::errors() const {
  // @@protoc_insertion_point(field_list:logi.proto.LRSetCloudConnectionStateResponse.errors)
  return errors_;
}

// .logi.proto.HostInformation host_information = 2;
inline bool LRSetCloudConnectionStateResponse::has_host_information() const {
  return this != internal_default_instance() && host_information_ != NULL;
}
inline const ::logi::proto::HostInformation& LRSetCloudConnectionStateResponse::_internal_host_information() const {
  return *host_information_;
}
inline const ::logi::proto::HostInformation& LRSetCloudConnectionStateResponse::host_information() const {
  const ::logi::proto::HostInformation* p = host_information_;
  // @@protoc_insertion_point(field_get:logi.proto.LRSetCloudConnectionStateResponse.host_information)
  return p != NULL ? *p : *reinterpret_cast<const ::logi::proto::HostInformation*>(
      &::logi::proto::_HostInformation_default_instance_);
}
inline ::logi::proto::HostInformation* LRSetCloudConnectionStateResponse::release_host_information() {
  // @@protoc_insertion_point(field_release:logi.proto.LRSetCloudConnectionStateResponse.host_information)
  
  ::logi::proto::HostInformation* temp = host_information_;
  host_information_ = NULL;
  return temp;
}
inline ::logi::proto::HostInformation* LRSetCloudConnectionStateResponse::mutable_host_information() {
  
  if (host_information_ == NULL) {
    auto* p = CreateMaybeMessage<::logi::proto::HostInformation>(GetArenaNoVirtual());
    host_information_ = p;
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LRSetCloudConnectionStateResponse.host_information)
  return host_information_;
}
inline void LRSetCloudConnectionStateResponse::set_allocated_host_information(::logi::proto::HostInformation* host_information) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(host_information_);
  }
  if (host_information) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      host_information = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, host_information, submessage_arena);
    }
    
  } else {
    
  }
  host_information_ = host_information;
  // @@protoc_insertion_point(field_set_allocated:logi.proto.LRSetCloudConnectionStateResponse.host_information)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace logi

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_cloud_5fprovisioning_5frequests_2eproto
