// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: configuration_structures.proto

#ifndef PROTOBUF_INCLUDED_configuration_5fstructures_2eproto
#define PROTOBUF_INCLUDED_configuration_5fstructures_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_configuration_5fstructures_2eproto 

namespace protobuf_configuration_5fstructures_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_configuration_5fstructures_2eproto
namespace logi {
namespace proto {
class HostInformation;
class HostInformationDefaultTypeInternal;
extern HostInformationDefaultTypeInternal _HostInformation_default_instance_;
class HostInformation_Display;
class HostInformation_DisplayDefaultTypeInternal;
extern HostInformation_DisplayDefaultTypeInternal _HostInformation_Display_default_instance_;
class LogiSyncConfiguration;
class LogiSyncConfigurationDefaultTypeInternal;
extern LogiSyncConfigurationDefaultTypeInternal _LogiSyncConfiguration_default_instance_;
class LogiSyncConfiguration_ConfigurationEntry_DoNotUse;
class LogiSyncConfiguration_ConfigurationEntry_DoNotUseDefaultTypeInternal;
extern LogiSyncConfiguration_ConfigurationEntry_DoNotUseDefaultTypeInternal _LogiSyncConfiguration_ConfigurationEntry_DoNotUse_default_instance_;
}  // namespace proto
}  // namespace logi
namespace google {
namespace protobuf {
template<> ::logi::proto::HostInformation* Arena::CreateMaybeMessage<::logi::proto::HostInformation>(Arena*);
template<> ::logi::proto::HostInformation_Display* Arena::CreateMaybeMessage<::logi::proto::HostInformation_Display>(Arena*);
template<> ::logi::proto::LogiSyncConfiguration* Arena::CreateMaybeMessage<::logi::proto::LogiSyncConfiguration>(Arena*);
template<> ::logi::proto::LogiSyncConfiguration_ConfigurationEntry_DoNotUse* Arena::CreateMaybeMessage<::logi::proto::LogiSyncConfiguration_ConfigurationEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace logi {
namespace proto {

enum LogiSyncConfiguration_Option {
  LogiSyncConfiguration_Option_RESERVED = 0,
  LogiSyncConfiguration_Option_COLLECTING_ANALYTICS = 1,
  LogiSyncConfiguration_Option_ROOM_NAME = 2,
  LogiSyncConfiguration_Option_EULA_ACCEPTED = 3,
  LogiSyncConfiguration_Option_ORGANIZATION_NAME = 4,
  LogiSyncConfiguration_Option_LogiSyncConfiguration_Option_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LogiSyncConfiguration_Option_LogiSyncConfiguration_Option_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LogiSyncConfiguration_Option_IsValid(int value);
const LogiSyncConfiguration_Option LogiSyncConfiguration_Option_Option_MIN = LogiSyncConfiguration_Option_RESERVED;
const LogiSyncConfiguration_Option LogiSyncConfiguration_Option_Option_MAX = LogiSyncConfiguration_Option_ORGANIZATION_NAME;
const int LogiSyncConfiguration_Option_Option_ARRAYSIZE = LogiSyncConfiguration_Option_Option_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogiSyncConfiguration_Option_descriptor();
inline const ::std::string& LogiSyncConfiguration_Option_Name(LogiSyncConfiguration_Option value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogiSyncConfiguration_Option_descriptor(), value);
}
inline bool LogiSyncConfiguration_Option_Parse(
    const ::std::string& name, LogiSyncConfiguration_Option* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogiSyncConfiguration_Option>(
    LogiSyncConfiguration_Option_descriptor(), name, value);
}
// ===================================================================

class HostInformation_Display : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.HostInformation.Display) */ {
 public:
  HostInformation_Display();
  virtual ~HostInformation_Display();

  HostInformation_Display(const HostInformation_Display& from);

  inline HostInformation_Display& operator=(const HostInformation_Display& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HostInformation_Display(HostInformation_Display&& from) noexcept
    : HostInformation_Display() {
    *this = ::std::move(from);
  }

  inline HostInformation_Display& operator=(HostInformation_Display&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HostInformation_Display& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HostInformation_Display* internal_default_instance() {
    return reinterpret_cast<const HostInformation_Display*>(
               &_HostInformation_Display_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(HostInformation_Display* other);
  friend void swap(HostInformation_Display& a, HostInformation_Display& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HostInformation_Display* New() const final {
    return CreateMaybeMessage<HostInformation_Display>(NULL);
  }

  HostInformation_Display* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HostInformation_Display>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HostInformation_Display& from);
  void MergeFrom(const HostInformation_Display& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HostInformation_Display* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string resolution = 1;
  void clear_resolution();
  static const int kResolutionFieldNumber = 1;
  const ::std::string& resolution() const;
  void set_resolution(const ::std::string& value);
  #if LANG_CXX11
  void set_resolution(::std::string&& value);
  #endif
  void set_resolution(const char* value);
  void set_resolution(const char* value, size_t size);
  ::std::string* mutable_resolution();
  ::std::string* release_resolution();
  void set_allocated_resolution(::std::string* resolution);

  // string refresh_rate = 2;
  void clear_refresh_rate();
  static const int kRefreshRateFieldNumber = 2;
  const ::std::string& refresh_rate() const;
  void set_refresh_rate(const ::std::string& value);
  #if LANG_CXX11
  void set_refresh_rate(::std::string&& value);
  #endif
  void set_refresh_rate(const char* value);
  void set_refresh_rate(const char* value, size_t size);
  ::std::string* mutable_refresh_rate();
  ::std::string* release_refresh_rate();
  void set_allocated_refresh_rate(::std::string* refresh_rate);

  // @@protoc_insertion_point(class_scope:logi.proto.HostInformation.Display)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr resolution_;
  ::google::protobuf::internal::ArenaStringPtr refresh_rate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_configuration_5fstructures_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HostInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.HostInformation) */ {
 public:
  HostInformation();
  virtual ~HostInformation();

  HostInformation(const HostInformation& from);

  inline HostInformation& operator=(const HostInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HostInformation(HostInformation&& from) noexcept
    : HostInformation() {
    *this = ::std::move(from);
  }

  inline HostInformation& operator=(HostInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HostInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HostInformation* internal_default_instance() {
    return reinterpret_cast<const HostInformation*>(
               &_HostInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(HostInformation* other);
  friend void swap(HostInformation& a, HostInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HostInformation* New() const final {
    return CreateMaybeMessage<HostInformation>(NULL);
  }

  HostInformation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HostInformation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HostInformation& from);
  void MergeFrom(const HostInformation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HostInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HostInformation_Display Display;

  // accessors -------------------------------------------------------

  // repeated .logi.proto.HostInformation.Display displays = 6;
  int displays_size() const;
  void clear_displays();
  static const int kDisplaysFieldNumber = 6;
  ::logi::proto::HostInformation_Display* mutable_displays(int index);
  ::google::protobuf::RepeatedPtrField< ::logi::proto::HostInformation_Display >*
      mutable_displays();
  const ::logi::proto::HostInformation_Display& displays(int index) const;
  ::logi::proto::HostInformation_Display* add_displays();
  const ::google::protobuf::RepeatedPtrField< ::logi::proto::HostInformation_Display >&
      displays() const;

  // string hardware_model = 1;
  void clear_hardware_model();
  static const int kHardwareModelFieldNumber = 1;
  const ::std::string& hardware_model() const;
  void set_hardware_model(const ::std::string& value);
  #if LANG_CXX11
  void set_hardware_model(::std::string&& value);
  #endif
  void set_hardware_model(const char* value);
  void set_hardware_model(const char* value, size_t size);
  ::std::string* mutable_hardware_model();
  ::std::string* release_hardware_model();
  void set_allocated_hardware_model(::std::string* hardware_model);

  // string operating_system_name = 2;
  void clear_operating_system_name();
  static const int kOperatingSystemNameFieldNumber = 2;
  const ::std::string& operating_system_name() const;
  void set_operating_system_name(const ::std::string& value);
  #if LANG_CXX11
  void set_operating_system_name(::std::string&& value);
  #endif
  void set_operating_system_name(const char* value);
  void set_operating_system_name(const char* value, size_t size);
  ::std::string* mutable_operating_system_name();
  ::std::string* release_operating_system_name();
  void set_allocated_operating_system_name(::std::string* operating_system_name);

  // string operating_system_version = 3;
  void clear_operating_system_version();
  static const int kOperatingSystemVersionFieldNumber = 3;
  const ::std::string& operating_system_version() const;
  void set_operating_system_version(const ::std::string& value);
  #if LANG_CXX11
  void set_operating_system_version(::std::string&& value);
  #endif
  void set_operating_system_version(const char* value);
  void set_operating_system_version(const char* value, size_t size);
  ::std::string* mutable_operating_system_version();
  ::std::string* release_operating_system_version();
  void set_allocated_operating_system_version(::std::string* operating_system_version);

  // string processor = 4;
  void clear_processor();
  static const int kProcessorFieldNumber = 4;
  const ::std::string& processor() const;
  void set_processor(const ::std::string& value);
  #if LANG_CXX11
  void set_processor(::std::string&& value);
  #endif
  void set_processor(const char* value);
  void set_processor(const char* value, size_t size);
  ::std::string* mutable_processor();
  ::std::string* release_processor();
  void set_allocated_processor(::std::string* processor);

  // string memory = 5;
  void clear_memory();
  static const int kMemoryFieldNumber = 5;
  const ::std::string& memory() const;
  void set_memory(const ::std::string& value);
  #if LANG_CXX11
  void set_memory(::std::string&& value);
  #endif
  void set_memory(const char* value);
  void set_memory(const char* value, size_t size);
  ::std::string* mutable_memory();
  ::std::string* release_memory();
  void set_allocated_memory(::std::string* memory);

  // string host_name = 7;
  void clear_host_name();
  static const int kHostNameFieldNumber = 7;
  const ::std::string& host_name() const;
  void set_host_name(const ::std::string& value);
  #if LANG_CXX11
  void set_host_name(::std::string&& value);
  #endif
  void set_host_name(const char* value);
  void set_host_name(const char* value, size_t size);
  ::std::string* mutable_host_name();
  ::std::string* release_host_name();
  void set_allocated_host_name(::std::string* host_name);

  // @@protoc_insertion_point(class_scope:logi.proto.HostInformation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::logi::proto::HostInformation_Display > displays_;
  ::google::protobuf::internal::ArenaStringPtr hardware_model_;
  ::google::protobuf::internal::ArenaStringPtr operating_system_name_;
  ::google::protobuf::internal::ArenaStringPtr operating_system_version_;
  ::google::protobuf::internal::ArenaStringPtr processor_;
  ::google::protobuf::internal::ArenaStringPtr memory_;
  ::google::protobuf::internal::ArenaStringPtr host_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_configuration_5fstructures_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogiSyncConfiguration_ConfigurationEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<LogiSyncConfiguration_ConfigurationEntry_DoNotUse, 
    ::google::protobuf::uint32, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<LogiSyncConfiguration_ConfigurationEntry_DoNotUse, 
    ::google::protobuf::uint32, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  LogiSyncConfiguration_ConfigurationEntry_DoNotUse();
  LogiSyncConfiguration_ConfigurationEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const LogiSyncConfiguration_ConfigurationEntry_DoNotUse& other);
  static const LogiSyncConfiguration_ConfigurationEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LogiSyncConfiguration_ConfigurationEntry_DoNotUse*>(&_LogiSyncConfiguration_ConfigurationEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class LogiSyncConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.LogiSyncConfiguration) */ {
 public:
  LogiSyncConfiguration();
  virtual ~LogiSyncConfiguration();

  LogiSyncConfiguration(const LogiSyncConfiguration& from);

  inline LogiSyncConfiguration& operator=(const LogiSyncConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogiSyncConfiguration(LogiSyncConfiguration&& from) noexcept
    : LogiSyncConfiguration() {
    *this = ::std::move(from);
  }

  inline LogiSyncConfiguration& operator=(LogiSyncConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogiSyncConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogiSyncConfiguration* internal_default_instance() {
    return reinterpret_cast<const LogiSyncConfiguration*>(
               &_LogiSyncConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(LogiSyncConfiguration* other);
  friend void swap(LogiSyncConfiguration& a, LogiSyncConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogiSyncConfiguration* New() const final {
    return CreateMaybeMessage<LogiSyncConfiguration>(NULL);
  }

  LogiSyncConfiguration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogiSyncConfiguration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogiSyncConfiguration& from);
  void MergeFrom(const LogiSyncConfiguration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogiSyncConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef LogiSyncConfiguration_Option Option;
  static const Option RESERVED =
    LogiSyncConfiguration_Option_RESERVED;
  static const Option COLLECTING_ANALYTICS =
    LogiSyncConfiguration_Option_COLLECTING_ANALYTICS;
  static const Option ROOM_NAME =
    LogiSyncConfiguration_Option_ROOM_NAME;
  static const Option EULA_ACCEPTED =
    LogiSyncConfiguration_Option_EULA_ACCEPTED;
  static const Option ORGANIZATION_NAME =
    LogiSyncConfiguration_Option_ORGANIZATION_NAME;
  static inline bool Option_IsValid(int value) {
    return LogiSyncConfiguration_Option_IsValid(value);
  }
  static const Option Option_MIN =
    LogiSyncConfiguration_Option_Option_MIN;
  static const Option Option_MAX =
    LogiSyncConfiguration_Option_Option_MAX;
  static const int Option_ARRAYSIZE =
    LogiSyncConfiguration_Option_Option_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Option_descriptor() {
    return LogiSyncConfiguration_Option_descriptor();
  }
  static inline const ::std::string& Option_Name(Option value) {
    return LogiSyncConfiguration_Option_Name(value);
  }
  static inline bool Option_Parse(const ::std::string& name,
      Option* value) {
    return LogiSyncConfiguration_Option_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // map<uint32, string> configuration = 1;
  int configuration_size() const;
  void clear_configuration();
  static const int kConfigurationFieldNumber = 1;
  const ::google::protobuf::Map< ::google::protobuf::uint32, ::std::string >&
      configuration() const;
  ::google::protobuf::Map< ::google::protobuf::uint32, ::std::string >*
      mutable_configuration();

  // @@protoc_insertion_point(class_scope:logi.proto.LogiSyncConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      LogiSyncConfiguration_ConfigurationEntry_DoNotUse,
      ::google::protobuf::uint32, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > configuration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_configuration_5fstructures_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HostInformation_Display

// string resolution = 1;
inline void HostInformation_Display::clear_resolution() {
  resolution_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HostInformation_Display::resolution() const {
  // @@protoc_insertion_point(field_get:logi.proto.HostInformation.Display.resolution)
  return resolution_.GetNoArena();
}
inline void HostInformation_Display::set_resolution(const ::std::string& value) {
  
  resolution_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logi.proto.HostInformation.Display.resolution)
}
#if LANG_CXX11
inline void HostInformation_Display::set_resolution(::std::string&& value) {
  
  resolution_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:logi.proto.HostInformation.Display.resolution)
}
#endif
inline void HostInformation_Display::set_resolution(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  resolution_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logi.proto.HostInformation.Display.resolution)
}
inline void HostInformation_Display::set_resolution(const char* value, size_t size) {
  
  resolution_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logi.proto.HostInformation.Display.resolution)
}
inline ::std::string* HostInformation_Display::mutable_resolution() {
  
  // @@protoc_insertion_point(field_mutable:logi.proto.HostInformation.Display.resolution)
  return resolution_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HostInformation_Display::release_resolution() {
  // @@protoc_insertion_point(field_release:logi.proto.HostInformation.Display.resolution)
  
  return resolution_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HostInformation_Display::set_allocated_resolution(::std::string* resolution) {
  if (resolution != NULL) {
    
  } else {
    
  }
  resolution_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), resolution);
  // @@protoc_insertion_point(field_set_allocated:logi.proto.HostInformation.Display.resolution)
}

// string refresh_rate = 2;
inline void HostInformation_Display::clear_refresh_rate() {
  refresh_rate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HostInformation_Display::refresh_rate() const {
  // @@protoc_insertion_point(field_get:logi.proto.HostInformation.Display.refresh_rate)
  return refresh_rate_.GetNoArena();
}
inline void HostInformation_Display::set_refresh_rate(const ::std::string& value) {
  
  refresh_rate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logi.proto.HostInformation.Display.refresh_rate)
}
#if LANG_CXX11
inline void HostInformation_Display::set_refresh_rate(::std::string&& value) {
  
  refresh_rate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:logi.proto.HostInformation.Display.refresh_rate)
}
#endif
inline void HostInformation_Display::set_refresh_rate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  refresh_rate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logi.proto.HostInformation.Display.refresh_rate)
}
inline void HostInformation_Display::set_refresh_rate(const char* value, size_t size) {
  
  refresh_rate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logi.proto.HostInformation.Display.refresh_rate)
}
inline ::std::string* HostInformation_Display::mutable_refresh_rate() {
  
  // @@protoc_insertion_point(field_mutable:logi.proto.HostInformation.Display.refresh_rate)
  return refresh_rate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HostInformation_Display::release_refresh_rate() {
  // @@protoc_insertion_point(field_release:logi.proto.HostInformation.Display.refresh_rate)
  
  return refresh_rate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HostInformation_Display::set_allocated_refresh_rate(::std::string* refresh_rate) {
  if (refresh_rate != NULL) {
    
  } else {
    
  }
  refresh_rate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), refresh_rate);
  // @@protoc_insertion_point(field_set_allocated:logi.proto.HostInformation.Display.refresh_rate)
}

// -------------------------------------------------------------------

// HostInformation

// string hardware_model = 1;
inline void HostInformation::clear_hardware_model() {
  hardware_model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HostInformation::hardware_model() const {
  // @@protoc_insertion_point(field_get:logi.proto.HostInformation.hardware_model)
  return hardware_model_.GetNoArena();
}
inline void HostInformation::set_hardware_model(const ::std::string& value) {
  
  hardware_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logi.proto.HostInformation.hardware_model)
}
#if LANG_CXX11
inline void HostInformation::set_hardware_model(::std::string&& value) {
  
  hardware_model_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:logi.proto.HostInformation.hardware_model)
}
#endif
inline void HostInformation::set_hardware_model(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hardware_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logi.proto.HostInformation.hardware_model)
}
inline void HostInformation::set_hardware_model(const char* value, size_t size) {
  
  hardware_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logi.proto.HostInformation.hardware_model)
}
inline ::std::string* HostInformation::mutable_hardware_model() {
  
  // @@protoc_insertion_point(field_mutable:logi.proto.HostInformation.hardware_model)
  return hardware_model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HostInformation::release_hardware_model() {
  // @@protoc_insertion_point(field_release:logi.proto.HostInformation.hardware_model)
  
  return hardware_model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HostInformation::set_allocated_hardware_model(::std::string* hardware_model) {
  if (hardware_model != NULL) {
    
  } else {
    
  }
  hardware_model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hardware_model);
  // @@protoc_insertion_point(field_set_allocated:logi.proto.HostInformation.hardware_model)
}

// string operating_system_name = 2;
inline void HostInformation::clear_operating_system_name() {
  operating_system_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HostInformation::operating_system_name() const {
  // @@protoc_insertion_point(field_get:logi.proto.HostInformation.operating_system_name)
  return operating_system_name_.GetNoArena();
}
inline void HostInformation::set_operating_system_name(const ::std::string& value) {
  
  operating_system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logi.proto.HostInformation.operating_system_name)
}
#if LANG_CXX11
inline void HostInformation::set_operating_system_name(::std::string&& value) {
  
  operating_system_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:logi.proto.HostInformation.operating_system_name)
}
#endif
inline void HostInformation::set_operating_system_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  operating_system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logi.proto.HostInformation.operating_system_name)
}
inline void HostInformation::set_operating_system_name(const char* value, size_t size) {
  
  operating_system_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logi.proto.HostInformation.operating_system_name)
}
inline ::std::string* HostInformation::mutable_operating_system_name() {
  
  // @@protoc_insertion_point(field_mutable:logi.proto.HostInformation.operating_system_name)
  return operating_system_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HostInformation::release_operating_system_name() {
  // @@protoc_insertion_point(field_release:logi.proto.HostInformation.operating_system_name)
  
  return operating_system_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HostInformation::set_allocated_operating_system_name(::std::string* operating_system_name) {
  if (operating_system_name != NULL) {
    
  } else {
    
  }
  operating_system_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), operating_system_name);
  // @@protoc_insertion_point(field_set_allocated:logi.proto.HostInformation.operating_system_name)
}

// string operating_system_version = 3;
inline void HostInformation::clear_operating_system_version() {
  operating_system_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HostInformation::operating_system_version() const {
  // @@protoc_insertion_point(field_get:logi.proto.HostInformation.operating_system_version)
  return operating_system_version_.GetNoArena();
}
inline void HostInformation::set_operating_system_version(const ::std::string& value) {
  
  operating_system_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logi.proto.HostInformation.operating_system_version)
}
#if LANG_CXX11
inline void HostInformation::set_operating_system_version(::std::string&& value) {
  
  operating_system_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:logi.proto.HostInformation.operating_system_version)
}
#endif
inline void HostInformation::set_operating_system_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  operating_system_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logi.proto.HostInformation.operating_system_version)
}
inline void HostInformation::set_operating_system_version(const char* value, size_t size) {
  
  operating_system_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logi.proto.HostInformation.operating_system_version)
}
inline ::std::string* HostInformation::mutable_operating_system_version() {
  
  // @@protoc_insertion_point(field_mutable:logi.proto.HostInformation.operating_system_version)
  return operating_system_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HostInformation::release_operating_system_version() {
  // @@protoc_insertion_point(field_release:logi.proto.HostInformation.operating_system_version)
  
  return operating_system_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HostInformation::set_allocated_operating_system_version(::std::string* operating_system_version) {
  if (operating_system_version != NULL) {
    
  } else {
    
  }
  operating_system_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), operating_system_version);
  // @@protoc_insertion_point(field_set_allocated:logi.proto.HostInformation.operating_system_version)
}

// string processor = 4;
inline void HostInformation::clear_processor() {
  processor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HostInformation::processor() const {
  // @@protoc_insertion_point(field_get:logi.proto.HostInformation.processor)
  return processor_.GetNoArena();
}
inline void HostInformation::set_processor(const ::std::string& value) {
  
  processor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logi.proto.HostInformation.processor)
}
#if LANG_CXX11
inline void HostInformation::set_processor(::std::string&& value) {
  
  processor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:logi.proto.HostInformation.processor)
}
#endif
inline void HostInformation::set_processor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  processor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logi.proto.HostInformation.processor)
}
inline void HostInformation::set_processor(const char* value, size_t size) {
  
  processor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logi.proto.HostInformation.processor)
}
inline ::std::string* HostInformation::mutable_processor() {
  
  // @@protoc_insertion_point(field_mutable:logi.proto.HostInformation.processor)
  return processor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HostInformation::release_processor() {
  // @@protoc_insertion_point(field_release:logi.proto.HostInformation.processor)
  
  return processor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HostInformation::set_allocated_processor(::std::string* processor) {
  if (processor != NULL) {
    
  } else {
    
  }
  processor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), processor);
  // @@protoc_insertion_point(field_set_allocated:logi.proto.HostInformation.processor)
}

// string memory = 5;
inline void HostInformation::clear_memory() {
  memory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HostInformation::memory() const {
  // @@protoc_insertion_point(field_get:logi.proto.HostInformation.memory)
  return memory_.GetNoArena();
}
inline void HostInformation::set_memory(const ::std::string& value) {
  
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logi.proto.HostInformation.memory)
}
#if LANG_CXX11
inline void HostInformation::set_memory(::std::string&& value) {
  
  memory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:logi.proto.HostInformation.memory)
}
#endif
inline void HostInformation::set_memory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logi.proto.HostInformation.memory)
}
inline void HostInformation::set_memory(const char* value, size_t size) {
  
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logi.proto.HostInformation.memory)
}
inline ::std::string* HostInformation::mutable_memory() {
  
  // @@protoc_insertion_point(field_mutable:logi.proto.HostInformation.memory)
  return memory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HostInformation::release_memory() {
  // @@protoc_insertion_point(field_release:logi.proto.HostInformation.memory)
  
  return memory_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HostInformation::set_allocated_memory(::std::string* memory) {
  if (memory != NULL) {
    
  } else {
    
  }
  memory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memory);
  // @@protoc_insertion_point(field_set_allocated:logi.proto.HostInformation.memory)
}

// repeated .logi.proto.HostInformation.Display displays = 6;
inline int HostInformation::displays_size() const {
  return displays_.size();
}
inline void HostInformation::clear_displays() {
  displays_.Clear();
}
inline ::logi::proto::HostInformation_Display* HostInformation::mutable_displays(int index) {
  // @@protoc_insertion_point(field_mutable:logi.proto.HostInformation.displays)
  return displays_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::logi::proto::HostInformation_Display >*
HostInformation::mutable_displays() {
  // @@protoc_insertion_point(field_mutable_list:logi.proto.HostInformation.displays)
  return &displays_;
}
inline const ::logi::proto::HostInformation_Display& HostInformation::displays(int index) const {
  // @@protoc_insertion_point(field_get:logi.proto.HostInformation.displays)
  return displays_.Get(index);
}
inline ::logi::proto::HostInformation_Display* HostInformation::add_displays() {
  // @@protoc_insertion_point(field_add:logi.proto.HostInformation.displays)
  return displays_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::logi::proto::HostInformation_Display >&
HostInformation::displays() const {
  // @@protoc_insertion_point(field_list:logi.proto.HostInformation.displays)
  return displays_;
}

// string host_name = 7;
inline void HostInformation::clear_host_name() {
  host_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HostInformation::host_name() const {
  // @@protoc_insertion_point(field_get:logi.proto.HostInformation.host_name)
  return host_name_.GetNoArena();
}
inline void HostInformation::set_host_name(const ::std::string& value) {
  
  host_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logi.proto.HostInformation.host_name)
}
#if LANG_CXX11
inline void HostInformation::set_host_name(::std::string&& value) {
  
  host_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:logi.proto.HostInformation.host_name)
}
#endif
inline void HostInformation::set_host_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  host_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logi.proto.HostInformation.host_name)
}
inline void HostInformation::set_host_name(const char* value, size_t size) {
  
  host_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logi.proto.HostInformation.host_name)
}
inline ::std::string* HostInformation::mutable_host_name() {
  
  // @@protoc_insertion_point(field_mutable:logi.proto.HostInformation.host_name)
  return host_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HostInformation::release_host_name() {
  // @@protoc_insertion_point(field_release:logi.proto.HostInformation.host_name)
  
  return host_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HostInformation::set_allocated_host_name(::std::string* host_name) {
  if (host_name != NULL) {
    
  } else {
    
  }
  host_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_name);
  // @@protoc_insertion_point(field_set_allocated:logi.proto.HostInformation.host_name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LogiSyncConfiguration

// map<uint32, string> configuration = 1;
inline int LogiSyncConfiguration::configuration_size() const {
  return configuration_.size();
}
inline void LogiSyncConfiguration::clear_configuration() {
  configuration_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint32, ::std::string >&
LogiSyncConfiguration::configuration() const {
  // @@protoc_insertion_point(field_map:logi.proto.LogiSyncConfiguration.configuration)
  return configuration_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint32, ::std::string >*
LogiSyncConfiguration::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable_map:logi.proto.LogiSyncConfiguration.configuration)
  return configuration_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace logi

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::logi::proto::LogiSyncConfiguration_Option> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::logi::proto::LogiSyncConfiguration_Option>() {
  return ::logi::proto::LogiSyncConfiguration_Option_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_configuration_5fstructures_2eproto
