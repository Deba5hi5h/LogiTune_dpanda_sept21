// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cloud_message.proto

#ifndef PROTOBUF_INCLUDED_cloud_5fmessage_2eproto
#define PROTOBUF_INCLUDED_cloud_5fmessage_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "transport.pb.h"
#include "cloud_provisioning_requests.pb.h"
#include "cloud_provisioning_events.pb.h"
#include "cloud_device_events.pb.h"
#include "cloud_device_requests.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_cloud_5fmessage_2eproto 

namespace protobuf_cloud_5fmessage_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_cloud_5fmessage_2eproto
namespace logi {
namespace proto {
class LREvent;
class LREventDefaultTypeInternal;
extern LREventDefaultTypeInternal _LREvent_default_instance_;
class LRRequest;
class LRRequestDefaultTypeInternal;
extern LRRequestDefaultTypeInternal _LRRequest_default_instance_;
class LRResponse;
class LRResponseDefaultTypeInternal;
extern LRResponseDefaultTypeInternal _LRResponse_default_instance_;
class LogiRaidenMessage;
class LogiRaidenMessageDefaultTypeInternal;
extern LogiRaidenMessageDefaultTypeInternal _LogiRaidenMessage_default_instance_;
}  // namespace proto
}  // namespace logi
namespace google {
namespace protobuf {
template<> ::logi::proto::LREvent* Arena::CreateMaybeMessage<::logi::proto::LREvent>(Arena*);
template<> ::logi::proto::LRRequest* Arena::CreateMaybeMessage<::logi::proto::LRRequest>(Arena*);
template<> ::logi::proto::LRResponse* Arena::CreateMaybeMessage<::logi::proto::LRResponse>(Arena*);
template<> ::logi::proto::LogiRaidenMessage* Arena::CreateMaybeMessage<::logi::proto::LogiRaidenMessage>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace logi {
namespace proto {

enum LogiRaidenMessage_Source {
  LogiRaidenMessage_Source_UNAVAILABLE = 0,
  LogiRaidenMessage_Source_CLIENT = 1,
  LogiRaidenMessage_Source_PROXY = 2,
  LogiRaidenMessage_Source_LogiRaidenMessage_Source_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LogiRaidenMessage_Source_LogiRaidenMessage_Source_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LogiRaidenMessage_Source_IsValid(int value);
const LogiRaidenMessage_Source LogiRaidenMessage_Source_Source_MIN = LogiRaidenMessage_Source_UNAVAILABLE;
const LogiRaidenMessage_Source LogiRaidenMessage_Source_Source_MAX = LogiRaidenMessage_Source_PROXY;
const int LogiRaidenMessage_Source_Source_ARRAYSIZE = LogiRaidenMessage_Source_Source_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogiRaidenMessage_Source_descriptor();
inline const ::std::string& LogiRaidenMessage_Source_Name(LogiRaidenMessage_Source value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogiRaidenMessage_Source_descriptor(), value);
}
inline bool LogiRaidenMessage_Source_Parse(
    const ::std::string& name, LogiRaidenMessage_Source* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogiRaidenMessage_Source>(
    LogiRaidenMessage_Source_descriptor(), name, value);
}
// ===================================================================

class LogiRaidenMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.LogiRaidenMessage) */ {
 public:
  LogiRaidenMessage();
  virtual ~LogiRaidenMessage();

  LogiRaidenMessage(const LogiRaidenMessage& from);

  inline LogiRaidenMessage& operator=(const LogiRaidenMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogiRaidenMessage(LogiRaidenMessage&& from) noexcept
    : LogiRaidenMessage() {
    *this = ::std::move(from);
  }

  inline LogiRaidenMessage& operator=(LogiRaidenMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogiRaidenMessage& default_instance();

  enum PayloadCase {
    kRequest = 4,
    kResponse = 5,
    kEvent = 6,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogiRaidenMessage* internal_default_instance() {
    return reinterpret_cast<const LogiRaidenMessage*>(
               &_LogiRaidenMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LogiRaidenMessage* other);
  friend void swap(LogiRaidenMessage& a, LogiRaidenMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogiRaidenMessage* New() const final {
    return CreateMaybeMessage<LogiRaidenMessage>(NULL);
  }

  LogiRaidenMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogiRaidenMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogiRaidenMessage& from);
  void MergeFrom(const LogiRaidenMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogiRaidenMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LogiRaidenMessage_Source Source;
  static const Source UNAVAILABLE =
    LogiRaidenMessage_Source_UNAVAILABLE;
  static const Source CLIENT =
    LogiRaidenMessage_Source_CLIENT;
  static const Source PROXY =
    LogiRaidenMessage_Source_PROXY;
  static inline bool Source_IsValid(int value) {
    return LogiRaidenMessage_Source_IsValid(value);
  }
  static const Source Source_MIN =
    LogiRaidenMessage_Source_Source_MIN;
  static const Source Source_MAX =
    LogiRaidenMessage_Source_Source_MAX;
  static const int Source_ARRAYSIZE =
    LogiRaidenMessage_Source_Source_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Source_descriptor() {
    return LogiRaidenMessage_Source_descriptor();
  }
  static inline const ::std::string& Source_Name(Source value) {
    return LogiRaidenMessage_Source_Name(value);
  }
  static inline bool Source_Parse(const ::std::string& name,
      Source* value) {
    return LogiRaidenMessage_Source_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .logi.proto.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::logi::proto::Header& _internal_header() const;
  public:
  const ::logi::proto::Header& header() const;
  ::logi::proto::Header* release_header();
  ::logi::proto::Header* mutable_header();
  void set_allocated_header(::logi::proto::Header* header);

  // .logi.proto.LogiRaidenMessage.Source source = 2;
  void clear_source();
  static const int kSourceFieldNumber = 2;
  ::logi::proto::LogiRaidenMessage_Source source() const;
  void set_source(::logi::proto::LogiRaidenMessage_Source value);

  // int32 internal_api_id = 3;
  void clear_internal_api_id();
  static const int kInternalApiIdFieldNumber = 3;
  ::google::protobuf::int32 internal_api_id() const;
  void set_internal_api_id(::google::protobuf::int32 value);

  // .logi.proto.LRRequest request = 4;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 4;
  private:
  const ::logi::proto::LRRequest& _internal_request() const;
  public:
  const ::logi::proto::LRRequest& request() const;
  ::logi::proto::LRRequest* release_request();
  ::logi::proto::LRRequest* mutable_request();
  void set_allocated_request(::logi::proto::LRRequest* request);

  // .logi.proto.LRResponse response = 5;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 5;
  private:
  const ::logi::proto::LRResponse& _internal_response() const;
  public:
  const ::logi::proto::LRResponse& response() const;
  ::logi::proto::LRResponse* release_response();
  ::logi::proto::LRResponse* mutable_response();
  void set_allocated_response(::logi::proto::LRResponse* response);

  // .logi.proto.LREvent event = 6;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 6;
  private:
  const ::logi::proto::LREvent& _internal_event() const;
  public:
  const ::logi::proto::LREvent& event() const;
  ::logi::proto::LREvent* release_event();
  ::logi::proto::LREvent* mutable_event();
  void set_allocated_event(::logi::proto::LREvent* event);

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:logi.proto.LogiRaidenMessage)
 private:
  void set_has_request();
  void set_has_response();
  void set_has_event();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::logi::proto::Header* header_;
  int source_;
  ::google::protobuf::int32 internal_api_id_;
  union PayloadUnion {
    PayloadUnion() {}
    ::logi::proto::LRRequest* request_;
    ::logi::proto::LRResponse* response_;
    ::logi::proto::LREvent* event_;
  } payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_cloud_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LRRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.LRRequest) */ {
 public:
  LRRequest();
  virtual ~LRRequest();

  LRRequest(const LRRequest& from);

  inline LRRequest& operator=(const LRRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LRRequest(LRRequest&& from) noexcept
    : LRRequest() {
    *this = ::std::move(from);
  }

  inline LRRequest& operator=(LRRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LRRequest& default_instance();

  enum PayloadCase {
    kProvisionHostRequest = 1,
    kDeprovisionHostRequest = 2,
    kGetProvisioningDataRequest = 3,
    kSetCloudConnectionStateRequest = 4,
    kCheckForProductUpdateRequest = 5,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LRRequest* internal_default_instance() {
    return reinterpret_cast<const LRRequest*>(
               &_LRRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(LRRequest* other);
  friend void swap(LRRequest& a, LRRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LRRequest* New() const final {
    return CreateMaybeMessage<LRRequest>(NULL);
  }

  LRRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LRRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LRRequest& from);
  void MergeFrom(const LRRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LRRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .logi.proto.LRProvisionHostRequest provision_host_request = 1;
  bool has_provision_host_request() const;
  void clear_provision_host_request();
  static const int kProvisionHostRequestFieldNumber = 1;
  private:
  const ::logi::proto::LRProvisionHostRequest& _internal_provision_host_request() const;
  public:
  const ::logi::proto::LRProvisionHostRequest& provision_host_request() const;
  ::logi::proto::LRProvisionHostRequest* release_provision_host_request();
  ::logi::proto::LRProvisionHostRequest* mutable_provision_host_request();
  void set_allocated_provision_host_request(::logi::proto::LRProvisionHostRequest* provision_host_request);

  // .logi.proto.LRDeprovisionHostRequest deprovision_host_request = 2;
  bool has_deprovision_host_request() const;
  void clear_deprovision_host_request();
  static const int kDeprovisionHostRequestFieldNumber = 2;
  private:
  const ::logi::proto::LRDeprovisionHostRequest& _internal_deprovision_host_request() const;
  public:
  const ::logi::proto::LRDeprovisionHostRequest& deprovision_host_request() const;
  ::logi::proto::LRDeprovisionHostRequest* release_deprovision_host_request();
  ::logi::proto::LRDeprovisionHostRequest* mutable_deprovision_host_request();
  void set_allocated_deprovision_host_request(::logi::proto::LRDeprovisionHostRequest* deprovision_host_request);

  // .logi.proto.LRGetProvisioningDataRequest get_provisioning_data_request = 3;
  bool has_get_provisioning_data_request() const;
  void clear_get_provisioning_data_request();
  static const int kGetProvisioningDataRequestFieldNumber = 3;
  private:
  const ::logi::proto::LRGetProvisioningDataRequest& _internal_get_provisioning_data_request() const;
  public:
  const ::logi::proto::LRGetProvisioningDataRequest& get_provisioning_data_request() const;
  ::logi::proto::LRGetProvisioningDataRequest* release_get_provisioning_data_request();
  ::logi::proto::LRGetProvisioningDataRequest* mutable_get_provisioning_data_request();
  void set_allocated_get_provisioning_data_request(::logi::proto::LRGetProvisioningDataRequest* get_provisioning_data_request);

  // .logi.proto.LRSetCloudConnectionStateRequest set_cloud_connection_state_request = 4;
  bool has_set_cloud_connection_state_request() const;
  void clear_set_cloud_connection_state_request();
  static const int kSetCloudConnectionStateRequestFieldNumber = 4;
  private:
  const ::logi::proto::LRSetCloudConnectionStateRequest& _internal_set_cloud_connection_state_request() const;
  public:
  const ::logi::proto::LRSetCloudConnectionStateRequest& set_cloud_connection_state_request() const;
  ::logi::proto::LRSetCloudConnectionStateRequest* release_set_cloud_connection_state_request();
  ::logi::proto::LRSetCloudConnectionStateRequest* mutable_set_cloud_connection_state_request();
  void set_allocated_set_cloud_connection_state_request(::logi::proto::LRSetCloudConnectionStateRequest* set_cloud_connection_state_request);

  // .logi.proto.LRCheckForProductUpdateRequest check_for_product_update_request = 5;
  bool has_check_for_product_update_request() const;
  void clear_check_for_product_update_request();
  static const int kCheckForProductUpdateRequestFieldNumber = 5;
  private:
  const ::logi::proto::LRCheckForProductUpdateRequest& _internal_check_for_product_update_request() const;
  public:
  const ::logi::proto::LRCheckForProductUpdateRequest& check_for_product_update_request() const;
  ::logi::proto::LRCheckForProductUpdateRequest* release_check_for_product_update_request();
  ::logi::proto::LRCheckForProductUpdateRequest* mutable_check_for_product_update_request();
  void set_allocated_check_for_product_update_request(::logi::proto::LRCheckForProductUpdateRequest* check_for_product_update_request);

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:logi.proto.LRRequest)
 private:
  void set_has_provision_host_request();
  void set_has_deprovision_host_request();
  void set_has_get_provisioning_data_request();
  void set_has_set_cloud_connection_state_request();
  void set_has_check_for_product_update_request();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union PayloadUnion {
    PayloadUnion() {}
    ::logi::proto::LRProvisionHostRequest* provision_host_request_;
    ::logi::proto::LRDeprovisionHostRequest* deprovision_host_request_;
    ::logi::proto::LRGetProvisioningDataRequest* get_provisioning_data_request_;
    ::logi::proto::LRSetCloudConnectionStateRequest* set_cloud_connection_state_request_;
    ::logi::proto::LRCheckForProductUpdateRequest* check_for_product_update_request_;
  } payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_cloud_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LRResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.LRResponse) */ {
 public:
  LRResponse();
  virtual ~LRResponse();

  LRResponse(const LRResponse& from);

  inline LRResponse& operator=(const LRResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LRResponse(LRResponse&& from) noexcept
    : LRResponse() {
    *this = ::std::move(from);
  }

  inline LRResponse& operator=(LRResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LRResponse& default_instance();

  enum PayloadCase {
    kProvisionHostResponse = 1,
    kDeprovisionHostResponse = 2,
    kGetProvisioningDataResponse = 3,
    kSetCloudConnectionStateResponse = 4,
    kCheckForProductUpdateResponse = 5,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LRResponse* internal_default_instance() {
    return reinterpret_cast<const LRResponse*>(
               &_LRResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LRResponse* other);
  friend void swap(LRResponse& a, LRResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LRResponse* New() const final {
    return CreateMaybeMessage<LRResponse>(NULL);
  }

  LRResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LRResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LRResponse& from);
  void MergeFrom(const LRResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LRResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .logi.proto.LRProvisionHostResponse provision_host_response = 1;
  bool has_provision_host_response() const;
  void clear_provision_host_response();
  static const int kProvisionHostResponseFieldNumber = 1;
  private:
  const ::logi::proto::LRProvisionHostResponse& _internal_provision_host_response() const;
  public:
  const ::logi::proto::LRProvisionHostResponse& provision_host_response() const;
  ::logi::proto::LRProvisionHostResponse* release_provision_host_response();
  ::logi::proto::LRProvisionHostResponse* mutable_provision_host_response();
  void set_allocated_provision_host_response(::logi::proto::LRProvisionHostResponse* provision_host_response);

  // .logi.proto.LRDeprovisionHostResponse deprovision_host_response = 2;
  bool has_deprovision_host_response() const;
  void clear_deprovision_host_response();
  static const int kDeprovisionHostResponseFieldNumber = 2;
  private:
  const ::logi::proto::LRDeprovisionHostResponse& _internal_deprovision_host_response() const;
  public:
  const ::logi::proto::LRDeprovisionHostResponse& deprovision_host_response() const;
  ::logi::proto::LRDeprovisionHostResponse* release_deprovision_host_response();
  ::logi::proto::LRDeprovisionHostResponse* mutable_deprovision_host_response();
  void set_allocated_deprovision_host_response(::logi::proto::LRDeprovisionHostResponse* deprovision_host_response);

  // .logi.proto.LRGetProvisioningDataResponse get_provisioning_data_response = 3;
  bool has_get_provisioning_data_response() const;
  void clear_get_provisioning_data_response();
  static const int kGetProvisioningDataResponseFieldNumber = 3;
  private:
  const ::logi::proto::LRGetProvisioningDataResponse& _internal_get_provisioning_data_response() const;
  public:
  const ::logi::proto::LRGetProvisioningDataResponse& get_provisioning_data_response() const;
  ::logi::proto::LRGetProvisioningDataResponse* release_get_provisioning_data_response();
  ::logi::proto::LRGetProvisioningDataResponse* mutable_get_provisioning_data_response();
  void set_allocated_get_provisioning_data_response(::logi::proto::LRGetProvisioningDataResponse* get_provisioning_data_response);

  // .logi.proto.LRSetCloudConnectionStateResponse set_cloud_connection_state_response = 4;
  bool has_set_cloud_connection_state_response() const;
  void clear_set_cloud_connection_state_response();
  static const int kSetCloudConnectionStateResponseFieldNumber = 4;
  private:
  const ::logi::proto::LRSetCloudConnectionStateResponse& _internal_set_cloud_connection_state_response() const;
  public:
  const ::logi::proto::LRSetCloudConnectionStateResponse& set_cloud_connection_state_response() const;
  ::logi::proto::LRSetCloudConnectionStateResponse* release_set_cloud_connection_state_response();
  ::logi::proto::LRSetCloudConnectionStateResponse* mutable_set_cloud_connection_state_response();
  void set_allocated_set_cloud_connection_state_response(::logi::proto::LRSetCloudConnectionStateResponse* set_cloud_connection_state_response);

  // .logi.proto.LRCheckForProductUpdateResponse check_for_product_update_response = 5;
  bool has_check_for_product_update_response() const;
  void clear_check_for_product_update_response();
  static const int kCheckForProductUpdateResponseFieldNumber = 5;
  private:
  const ::logi::proto::LRCheckForProductUpdateResponse& _internal_check_for_product_update_response() const;
  public:
  const ::logi::proto::LRCheckForProductUpdateResponse& check_for_product_update_response() const;
  ::logi::proto::LRCheckForProductUpdateResponse* release_check_for_product_update_response();
  ::logi::proto::LRCheckForProductUpdateResponse* mutable_check_for_product_update_response();
  void set_allocated_check_for_product_update_response(::logi::proto::LRCheckForProductUpdateResponse* check_for_product_update_response);

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:logi.proto.LRResponse)
 private:
  void set_has_provision_host_response();
  void set_has_deprovision_host_response();
  void set_has_get_provisioning_data_response();
  void set_has_set_cloud_connection_state_response();
  void set_has_check_for_product_update_response();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union PayloadUnion {
    PayloadUnion() {}
    ::logi::proto::LRProvisionHostResponse* provision_host_response_;
    ::logi::proto::LRDeprovisionHostResponse* deprovision_host_response_;
    ::logi::proto::LRGetProvisioningDataResponse* get_provisioning_data_response_;
    ::logi::proto::LRSetCloudConnectionStateResponse* set_cloud_connection_state_response_;
    ::logi::proto::LRCheckForProductUpdateResponse* check_for_product_update_response_;
  } payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_cloud_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LREvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logi.proto.LREvent) */ {
 public:
  LREvent();
  virtual ~LREvent();

  LREvent(const LREvent& from);

  inline LREvent& operator=(const LREvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LREvent(LREvent&& from) noexcept
    : LREvent() {
    *this = ::std::move(from);
  }

  inline LREvent& operator=(LREvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LREvent& default_instance();

  enum PayloadCase {
    kProvisioningDataAvailableEvent = 1,
    kProductUpdatedEvent = 2,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LREvent* internal_default_instance() {
    return reinterpret_cast<const LREvent*>(
               &_LREvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(LREvent* other);
  friend void swap(LREvent& a, LREvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LREvent* New() const final {
    return CreateMaybeMessage<LREvent>(NULL);
  }

  LREvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LREvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LREvent& from);
  void MergeFrom(const LREvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LREvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .logi.proto.LRProvisioningDataAvailableEvent provisioning_data_available_event = 1;
  bool has_provisioning_data_available_event() const;
  void clear_provisioning_data_available_event();
  static const int kProvisioningDataAvailableEventFieldNumber = 1;
  private:
  const ::logi::proto::LRProvisioningDataAvailableEvent& _internal_provisioning_data_available_event() const;
  public:
  const ::logi::proto::LRProvisioningDataAvailableEvent& provisioning_data_available_event() const;
  ::logi::proto::LRProvisioningDataAvailableEvent* release_provisioning_data_available_event();
  ::logi::proto::LRProvisioningDataAvailableEvent* mutable_provisioning_data_available_event();
  void set_allocated_provisioning_data_available_event(::logi::proto::LRProvisioningDataAvailableEvent* provisioning_data_available_event);

  // .logi.proto.LRProductUpdatedEvent product_updated_event = 2;
  bool has_product_updated_event() const;
  void clear_product_updated_event();
  static const int kProductUpdatedEventFieldNumber = 2;
  private:
  const ::logi::proto::LRProductUpdatedEvent& _internal_product_updated_event() const;
  public:
  const ::logi::proto::LRProductUpdatedEvent& product_updated_event() const;
  ::logi::proto::LRProductUpdatedEvent* release_product_updated_event();
  ::logi::proto::LRProductUpdatedEvent* mutable_product_updated_event();
  void set_allocated_product_updated_event(::logi::proto::LRProductUpdatedEvent* product_updated_event);

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:logi.proto.LREvent)
 private:
  void set_has_provisioning_data_available_event();
  void set_has_product_updated_event();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union PayloadUnion {
    PayloadUnion() {}
    ::logi::proto::LRProvisioningDataAvailableEvent* provisioning_data_available_event_;
    ::logi::proto::LRProductUpdatedEvent* product_updated_event_;
  } payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_cloud_5fmessage_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LogiRaidenMessage

// .logi.proto.Header header = 1;
inline bool LogiRaidenMessage::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::logi::proto::Header& LogiRaidenMessage::_internal_header() const {
  return *header_;
}
inline const ::logi::proto::Header& LogiRaidenMessage::header() const {
  const ::logi::proto::Header* p = header_;
  // @@protoc_insertion_point(field_get:logi.proto.LogiRaidenMessage.header)
  return p != NULL ? *p : *reinterpret_cast<const ::logi::proto::Header*>(
      &::logi::proto::_Header_default_instance_);
}
inline ::logi::proto::Header* LogiRaidenMessage::release_header() {
  // @@protoc_insertion_point(field_release:logi.proto.LogiRaidenMessage.header)
  
  ::logi::proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::logi::proto::Header* LogiRaidenMessage::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::logi::proto::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LogiRaidenMessage.header)
  return header_;
}
inline void LogiRaidenMessage::set_allocated_header(::logi::proto::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:logi.proto.LogiRaidenMessage.header)
}

// .logi.proto.LogiRaidenMessage.Source source = 2;
inline void LogiRaidenMessage::clear_source() {
  source_ = 0;
}
inline ::logi::proto::LogiRaidenMessage_Source LogiRaidenMessage::source() const {
  // @@protoc_insertion_point(field_get:logi.proto.LogiRaidenMessage.source)
  return static_cast< ::logi::proto::LogiRaidenMessage_Source >(source_);
}
inline void LogiRaidenMessage::set_source(::logi::proto::LogiRaidenMessage_Source value) {
  
  source_ = value;
  // @@protoc_insertion_point(field_set:logi.proto.LogiRaidenMessage.source)
}

// int32 internal_api_id = 3;
inline void LogiRaidenMessage::clear_internal_api_id() {
  internal_api_id_ = 0;
}
inline ::google::protobuf::int32 LogiRaidenMessage::internal_api_id() const {
  // @@protoc_insertion_point(field_get:logi.proto.LogiRaidenMessage.internal_api_id)
  return internal_api_id_;
}
inline void LogiRaidenMessage::set_internal_api_id(::google::protobuf::int32 value) {
  
  internal_api_id_ = value;
  // @@protoc_insertion_point(field_set:logi.proto.LogiRaidenMessage.internal_api_id)
}

// .logi.proto.LRRequest request = 4;
inline bool LogiRaidenMessage::has_request() const {
  return payload_case() == kRequest;
}
inline void LogiRaidenMessage::set_has_request() {
  _oneof_case_[0] = kRequest;
}
inline void LogiRaidenMessage::clear_request() {
  if (has_request()) {
    delete payload_.request_;
    clear_has_payload();
  }
}
inline const ::logi::proto::LRRequest& LogiRaidenMessage::_internal_request() const {
  return *payload_.request_;
}
inline ::logi::proto::LRRequest* LogiRaidenMessage::release_request() {
  // @@protoc_insertion_point(field_release:logi.proto.LogiRaidenMessage.request)
  if (has_request()) {
    clear_has_payload();
      ::logi::proto::LRRequest* temp = payload_.request_;
    payload_.request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::logi::proto::LRRequest& LogiRaidenMessage::request() const {
  // @@protoc_insertion_point(field_get:logi.proto.LogiRaidenMessage.request)
  return has_request()
      ? *payload_.request_
      : *reinterpret_cast< ::logi::proto::LRRequest*>(&::logi::proto::_LRRequest_default_instance_);
}
inline ::logi::proto::LRRequest* LogiRaidenMessage::mutable_request() {
  if (!has_request()) {
    clear_payload();
    set_has_request();
    payload_.request_ = CreateMaybeMessage< ::logi::proto::LRRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LogiRaidenMessage.request)
  return payload_.request_;
}

// .logi.proto.LRResponse response = 5;
inline bool LogiRaidenMessage::has_response() const {
  return payload_case() == kResponse;
}
inline void LogiRaidenMessage::set_has_response() {
  _oneof_case_[0] = kResponse;
}
inline void LogiRaidenMessage::clear_response() {
  if (has_response()) {
    delete payload_.response_;
    clear_has_payload();
  }
}
inline const ::logi::proto::LRResponse& LogiRaidenMessage::_internal_response() const {
  return *payload_.response_;
}
inline ::logi::proto::LRResponse* LogiRaidenMessage::release_response() {
  // @@protoc_insertion_point(field_release:logi.proto.LogiRaidenMessage.response)
  if (has_response()) {
    clear_has_payload();
      ::logi::proto::LRResponse* temp = payload_.response_;
    payload_.response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::logi::proto::LRResponse& LogiRaidenMessage::response() const {
  // @@protoc_insertion_point(field_get:logi.proto.LogiRaidenMessage.response)
  return has_response()
      ? *payload_.response_
      : *reinterpret_cast< ::logi::proto::LRResponse*>(&::logi::proto::_LRResponse_default_instance_);
}
inline ::logi::proto::LRResponse* LogiRaidenMessage::mutable_response() {
  if (!has_response()) {
    clear_payload();
    set_has_response();
    payload_.response_ = CreateMaybeMessage< ::logi::proto::LRResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LogiRaidenMessage.response)
  return payload_.response_;
}

// .logi.proto.LREvent event = 6;
inline bool LogiRaidenMessage::has_event() const {
  return payload_case() == kEvent;
}
inline void LogiRaidenMessage::set_has_event() {
  _oneof_case_[0] = kEvent;
}
inline void LogiRaidenMessage::clear_event() {
  if (has_event()) {
    delete payload_.event_;
    clear_has_payload();
  }
}
inline const ::logi::proto::LREvent& LogiRaidenMessage::_internal_event() const {
  return *payload_.event_;
}
inline ::logi::proto::LREvent* LogiRaidenMessage::release_event() {
  // @@protoc_insertion_point(field_release:logi.proto.LogiRaidenMessage.event)
  if (has_event()) {
    clear_has_payload();
      ::logi::proto::LREvent* temp = payload_.event_;
    payload_.event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::logi::proto::LREvent& LogiRaidenMessage::event() const {
  // @@protoc_insertion_point(field_get:logi.proto.LogiRaidenMessage.event)
  return has_event()
      ? *payload_.event_
      : *reinterpret_cast< ::logi::proto::LREvent*>(&::logi::proto::_LREvent_default_instance_);
}
inline ::logi::proto::LREvent* LogiRaidenMessage::mutable_event() {
  if (!has_event()) {
    clear_payload();
    set_has_event();
    payload_.event_ = CreateMaybeMessage< ::logi::proto::LREvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LogiRaidenMessage.event)
  return payload_.event_;
}

inline bool LogiRaidenMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void LogiRaidenMessage::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline LogiRaidenMessage::PayloadCase LogiRaidenMessage::payload_case() const {
  return LogiRaidenMessage::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LRRequest

// .logi.proto.LRProvisionHostRequest provision_host_request = 1;
inline bool LRRequest::has_provision_host_request() const {
  return payload_case() == kProvisionHostRequest;
}
inline void LRRequest::set_has_provision_host_request() {
  _oneof_case_[0] = kProvisionHostRequest;
}
inline const ::logi::proto::LRProvisionHostRequest& LRRequest::_internal_provision_host_request() const {
  return *payload_.provision_host_request_;
}
inline ::logi::proto::LRProvisionHostRequest* LRRequest::release_provision_host_request() {
  // @@protoc_insertion_point(field_release:logi.proto.LRRequest.provision_host_request)
  if (has_provision_host_request()) {
    clear_has_payload();
      ::logi::proto::LRProvisionHostRequest* temp = payload_.provision_host_request_;
    payload_.provision_host_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::logi::proto::LRProvisionHostRequest& LRRequest::provision_host_request() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRRequest.provision_host_request)
  return has_provision_host_request()
      ? *payload_.provision_host_request_
      : *reinterpret_cast< ::logi::proto::LRProvisionHostRequest*>(&::logi::proto::_LRProvisionHostRequest_default_instance_);
}
inline ::logi::proto::LRProvisionHostRequest* LRRequest::mutable_provision_host_request() {
  if (!has_provision_host_request()) {
    clear_payload();
    set_has_provision_host_request();
    payload_.provision_host_request_ = CreateMaybeMessage< ::logi::proto::LRProvisionHostRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LRRequest.provision_host_request)
  return payload_.provision_host_request_;
}

// .logi.proto.LRDeprovisionHostRequest deprovision_host_request = 2;
inline bool LRRequest::has_deprovision_host_request() const {
  return payload_case() == kDeprovisionHostRequest;
}
inline void LRRequest::set_has_deprovision_host_request() {
  _oneof_case_[0] = kDeprovisionHostRequest;
}
inline const ::logi::proto::LRDeprovisionHostRequest& LRRequest::_internal_deprovision_host_request() const {
  return *payload_.deprovision_host_request_;
}
inline ::logi::proto::LRDeprovisionHostRequest* LRRequest::release_deprovision_host_request() {
  // @@protoc_insertion_point(field_release:logi.proto.LRRequest.deprovision_host_request)
  if (has_deprovision_host_request()) {
    clear_has_payload();
      ::logi::proto::LRDeprovisionHostRequest* temp = payload_.deprovision_host_request_;
    payload_.deprovision_host_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::logi::proto::LRDeprovisionHostRequest& LRRequest::deprovision_host_request() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRRequest.deprovision_host_request)
  return has_deprovision_host_request()
      ? *payload_.deprovision_host_request_
      : *reinterpret_cast< ::logi::proto::LRDeprovisionHostRequest*>(&::logi::proto::_LRDeprovisionHostRequest_default_instance_);
}
inline ::logi::proto::LRDeprovisionHostRequest* LRRequest::mutable_deprovision_host_request() {
  if (!has_deprovision_host_request()) {
    clear_payload();
    set_has_deprovision_host_request();
    payload_.deprovision_host_request_ = CreateMaybeMessage< ::logi::proto::LRDeprovisionHostRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LRRequest.deprovision_host_request)
  return payload_.deprovision_host_request_;
}

// .logi.proto.LRGetProvisioningDataRequest get_provisioning_data_request = 3;
inline bool LRRequest::has_get_provisioning_data_request() const {
  return payload_case() == kGetProvisioningDataRequest;
}
inline void LRRequest::set_has_get_provisioning_data_request() {
  _oneof_case_[0] = kGetProvisioningDataRequest;
}
inline const ::logi::proto::LRGetProvisioningDataRequest& LRRequest::_internal_get_provisioning_data_request() const {
  return *payload_.get_provisioning_data_request_;
}
inline ::logi::proto::LRGetProvisioningDataRequest* LRRequest::release_get_provisioning_data_request() {
  // @@protoc_insertion_point(field_release:logi.proto.LRRequest.get_provisioning_data_request)
  if (has_get_provisioning_data_request()) {
    clear_has_payload();
      ::logi::proto::LRGetProvisioningDataRequest* temp = payload_.get_provisioning_data_request_;
    payload_.get_provisioning_data_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::logi::proto::LRGetProvisioningDataRequest& LRRequest::get_provisioning_data_request() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRRequest.get_provisioning_data_request)
  return has_get_provisioning_data_request()
      ? *payload_.get_provisioning_data_request_
      : *reinterpret_cast< ::logi::proto::LRGetProvisioningDataRequest*>(&::logi::proto::_LRGetProvisioningDataRequest_default_instance_);
}
inline ::logi::proto::LRGetProvisioningDataRequest* LRRequest::mutable_get_provisioning_data_request() {
  if (!has_get_provisioning_data_request()) {
    clear_payload();
    set_has_get_provisioning_data_request();
    payload_.get_provisioning_data_request_ = CreateMaybeMessage< ::logi::proto::LRGetProvisioningDataRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LRRequest.get_provisioning_data_request)
  return payload_.get_provisioning_data_request_;
}

// .logi.proto.LRSetCloudConnectionStateRequest set_cloud_connection_state_request = 4;
inline bool LRRequest::has_set_cloud_connection_state_request() const {
  return payload_case() == kSetCloudConnectionStateRequest;
}
inline void LRRequest::set_has_set_cloud_connection_state_request() {
  _oneof_case_[0] = kSetCloudConnectionStateRequest;
}
inline const ::logi::proto::LRSetCloudConnectionStateRequest& LRRequest::_internal_set_cloud_connection_state_request() const {
  return *payload_.set_cloud_connection_state_request_;
}
inline ::logi::proto::LRSetCloudConnectionStateRequest* LRRequest::release_set_cloud_connection_state_request() {
  // @@protoc_insertion_point(field_release:logi.proto.LRRequest.set_cloud_connection_state_request)
  if (has_set_cloud_connection_state_request()) {
    clear_has_payload();
      ::logi::proto::LRSetCloudConnectionStateRequest* temp = payload_.set_cloud_connection_state_request_;
    payload_.set_cloud_connection_state_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::logi::proto::LRSetCloudConnectionStateRequest& LRRequest::set_cloud_connection_state_request() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRRequest.set_cloud_connection_state_request)
  return has_set_cloud_connection_state_request()
      ? *payload_.set_cloud_connection_state_request_
      : *reinterpret_cast< ::logi::proto::LRSetCloudConnectionStateRequest*>(&::logi::proto::_LRSetCloudConnectionStateRequest_default_instance_);
}
inline ::logi::proto::LRSetCloudConnectionStateRequest* LRRequest::mutable_set_cloud_connection_state_request() {
  if (!has_set_cloud_connection_state_request()) {
    clear_payload();
    set_has_set_cloud_connection_state_request();
    payload_.set_cloud_connection_state_request_ = CreateMaybeMessage< ::logi::proto::LRSetCloudConnectionStateRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LRRequest.set_cloud_connection_state_request)
  return payload_.set_cloud_connection_state_request_;
}

// .logi.proto.LRCheckForProductUpdateRequest check_for_product_update_request = 5;
inline bool LRRequest::has_check_for_product_update_request() const {
  return payload_case() == kCheckForProductUpdateRequest;
}
inline void LRRequest::set_has_check_for_product_update_request() {
  _oneof_case_[0] = kCheckForProductUpdateRequest;
}
inline const ::logi::proto::LRCheckForProductUpdateRequest& LRRequest::_internal_check_for_product_update_request() const {
  return *payload_.check_for_product_update_request_;
}
inline ::logi::proto::LRCheckForProductUpdateRequest* LRRequest::release_check_for_product_update_request() {
  // @@protoc_insertion_point(field_release:logi.proto.LRRequest.check_for_product_update_request)
  if (has_check_for_product_update_request()) {
    clear_has_payload();
      ::logi::proto::LRCheckForProductUpdateRequest* temp = payload_.check_for_product_update_request_;
    payload_.check_for_product_update_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::logi::proto::LRCheckForProductUpdateRequest& LRRequest::check_for_product_update_request() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRRequest.check_for_product_update_request)
  return has_check_for_product_update_request()
      ? *payload_.check_for_product_update_request_
      : *reinterpret_cast< ::logi::proto::LRCheckForProductUpdateRequest*>(&::logi::proto::_LRCheckForProductUpdateRequest_default_instance_);
}
inline ::logi::proto::LRCheckForProductUpdateRequest* LRRequest::mutable_check_for_product_update_request() {
  if (!has_check_for_product_update_request()) {
    clear_payload();
    set_has_check_for_product_update_request();
    payload_.check_for_product_update_request_ = CreateMaybeMessage< ::logi::proto::LRCheckForProductUpdateRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LRRequest.check_for_product_update_request)
  return payload_.check_for_product_update_request_;
}

inline bool LRRequest::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void LRRequest::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline LRRequest::PayloadCase LRRequest::payload_case() const {
  return LRRequest::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LRResponse

// .logi.proto.LRProvisionHostResponse provision_host_response = 1;
inline bool LRResponse::has_provision_host_response() const {
  return payload_case() == kProvisionHostResponse;
}
inline void LRResponse::set_has_provision_host_response() {
  _oneof_case_[0] = kProvisionHostResponse;
}
inline const ::logi::proto::LRProvisionHostResponse& LRResponse::_internal_provision_host_response() const {
  return *payload_.provision_host_response_;
}
inline ::logi::proto::LRProvisionHostResponse* LRResponse::release_provision_host_response() {
  // @@protoc_insertion_point(field_release:logi.proto.LRResponse.provision_host_response)
  if (has_provision_host_response()) {
    clear_has_payload();
      ::logi::proto::LRProvisionHostResponse* temp = payload_.provision_host_response_;
    payload_.provision_host_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::logi::proto::LRProvisionHostResponse& LRResponse::provision_host_response() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRResponse.provision_host_response)
  return has_provision_host_response()
      ? *payload_.provision_host_response_
      : *reinterpret_cast< ::logi::proto::LRProvisionHostResponse*>(&::logi::proto::_LRProvisionHostResponse_default_instance_);
}
inline ::logi::proto::LRProvisionHostResponse* LRResponse::mutable_provision_host_response() {
  if (!has_provision_host_response()) {
    clear_payload();
    set_has_provision_host_response();
    payload_.provision_host_response_ = CreateMaybeMessage< ::logi::proto::LRProvisionHostResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LRResponse.provision_host_response)
  return payload_.provision_host_response_;
}

// .logi.proto.LRDeprovisionHostResponse deprovision_host_response = 2;
inline bool LRResponse::has_deprovision_host_response() const {
  return payload_case() == kDeprovisionHostResponse;
}
inline void LRResponse::set_has_deprovision_host_response() {
  _oneof_case_[0] = kDeprovisionHostResponse;
}
inline const ::logi::proto::LRDeprovisionHostResponse& LRResponse::_internal_deprovision_host_response() const {
  return *payload_.deprovision_host_response_;
}
inline ::logi::proto::LRDeprovisionHostResponse* LRResponse::release_deprovision_host_response() {
  // @@protoc_insertion_point(field_release:logi.proto.LRResponse.deprovision_host_response)
  if (has_deprovision_host_response()) {
    clear_has_payload();
      ::logi::proto::LRDeprovisionHostResponse* temp = payload_.deprovision_host_response_;
    payload_.deprovision_host_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::logi::proto::LRDeprovisionHostResponse& LRResponse::deprovision_host_response() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRResponse.deprovision_host_response)
  return has_deprovision_host_response()
      ? *payload_.deprovision_host_response_
      : *reinterpret_cast< ::logi::proto::LRDeprovisionHostResponse*>(&::logi::proto::_LRDeprovisionHostResponse_default_instance_);
}
inline ::logi::proto::LRDeprovisionHostResponse* LRResponse::mutable_deprovision_host_response() {
  if (!has_deprovision_host_response()) {
    clear_payload();
    set_has_deprovision_host_response();
    payload_.deprovision_host_response_ = CreateMaybeMessage< ::logi::proto::LRDeprovisionHostResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LRResponse.deprovision_host_response)
  return payload_.deprovision_host_response_;
}

// .logi.proto.LRGetProvisioningDataResponse get_provisioning_data_response = 3;
inline bool LRResponse::has_get_provisioning_data_response() const {
  return payload_case() == kGetProvisioningDataResponse;
}
inline void LRResponse::set_has_get_provisioning_data_response() {
  _oneof_case_[0] = kGetProvisioningDataResponse;
}
inline const ::logi::proto::LRGetProvisioningDataResponse& LRResponse::_internal_get_provisioning_data_response() const {
  return *payload_.get_provisioning_data_response_;
}
inline ::logi::proto::LRGetProvisioningDataResponse* LRResponse::release_get_provisioning_data_response() {
  // @@protoc_insertion_point(field_release:logi.proto.LRResponse.get_provisioning_data_response)
  if (has_get_provisioning_data_response()) {
    clear_has_payload();
      ::logi::proto::LRGetProvisioningDataResponse* temp = payload_.get_provisioning_data_response_;
    payload_.get_provisioning_data_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::logi::proto::LRGetProvisioningDataResponse& LRResponse::get_provisioning_data_response() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRResponse.get_provisioning_data_response)
  return has_get_provisioning_data_response()
      ? *payload_.get_provisioning_data_response_
      : *reinterpret_cast< ::logi::proto::LRGetProvisioningDataResponse*>(&::logi::proto::_LRGetProvisioningDataResponse_default_instance_);
}
inline ::logi::proto::LRGetProvisioningDataResponse* LRResponse::mutable_get_provisioning_data_response() {
  if (!has_get_provisioning_data_response()) {
    clear_payload();
    set_has_get_provisioning_data_response();
    payload_.get_provisioning_data_response_ = CreateMaybeMessage< ::logi::proto::LRGetProvisioningDataResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LRResponse.get_provisioning_data_response)
  return payload_.get_provisioning_data_response_;
}

// .logi.proto.LRSetCloudConnectionStateResponse set_cloud_connection_state_response = 4;
inline bool LRResponse::has_set_cloud_connection_state_response() const {
  return payload_case() == kSetCloudConnectionStateResponse;
}
inline void LRResponse::set_has_set_cloud_connection_state_response() {
  _oneof_case_[0] = kSetCloudConnectionStateResponse;
}
inline const ::logi::proto::LRSetCloudConnectionStateResponse& LRResponse::_internal_set_cloud_connection_state_response() const {
  return *payload_.set_cloud_connection_state_response_;
}
inline ::logi::proto::LRSetCloudConnectionStateResponse* LRResponse::release_set_cloud_connection_state_response() {
  // @@protoc_insertion_point(field_release:logi.proto.LRResponse.set_cloud_connection_state_response)
  if (has_set_cloud_connection_state_response()) {
    clear_has_payload();
      ::logi::proto::LRSetCloudConnectionStateResponse* temp = payload_.set_cloud_connection_state_response_;
    payload_.set_cloud_connection_state_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::logi::proto::LRSetCloudConnectionStateResponse& LRResponse::set_cloud_connection_state_response() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRResponse.set_cloud_connection_state_response)
  return has_set_cloud_connection_state_response()
      ? *payload_.set_cloud_connection_state_response_
      : *reinterpret_cast< ::logi::proto::LRSetCloudConnectionStateResponse*>(&::logi::proto::_LRSetCloudConnectionStateResponse_default_instance_);
}
inline ::logi::proto::LRSetCloudConnectionStateResponse* LRResponse::mutable_set_cloud_connection_state_response() {
  if (!has_set_cloud_connection_state_response()) {
    clear_payload();
    set_has_set_cloud_connection_state_response();
    payload_.set_cloud_connection_state_response_ = CreateMaybeMessage< ::logi::proto::LRSetCloudConnectionStateResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LRResponse.set_cloud_connection_state_response)
  return payload_.set_cloud_connection_state_response_;
}

// .logi.proto.LRCheckForProductUpdateResponse check_for_product_update_response = 5;
inline bool LRResponse::has_check_for_product_update_response() const {
  return payload_case() == kCheckForProductUpdateResponse;
}
inline void LRResponse::set_has_check_for_product_update_response() {
  _oneof_case_[0] = kCheckForProductUpdateResponse;
}
inline const ::logi::proto::LRCheckForProductUpdateResponse& LRResponse::_internal_check_for_product_update_response() const {
  return *payload_.check_for_product_update_response_;
}
inline ::logi::proto::LRCheckForProductUpdateResponse* LRResponse::release_check_for_product_update_response() {
  // @@protoc_insertion_point(field_release:logi.proto.LRResponse.check_for_product_update_response)
  if (has_check_for_product_update_response()) {
    clear_has_payload();
      ::logi::proto::LRCheckForProductUpdateResponse* temp = payload_.check_for_product_update_response_;
    payload_.check_for_product_update_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::logi::proto::LRCheckForProductUpdateResponse& LRResponse::check_for_product_update_response() const {
  // @@protoc_insertion_point(field_get:logi.proto.LRResponse.check_for_product_update_response)
  return has_check_for_product_update_response()
      ? *payload_.check_for_product_update_response_
      : *reinterpret_cast< ::logi::proto::LRCheckForProductUpdateResponse*>(&::logi::proto::_LRCheckForProductUpdateResponse_default_instance_);
}
inline ::logi::proto::LRCheckForProductUpdateResponse* LRResponse::mutable_check_for_product_update_response() {
  if (!has_check_for_product_update_response()) {
    clear_payload();
    set_has_check_for_product_update_response();
    payload_.check_for_product_update_response_ = CreateMaybeMessage< ::logi::proto::LRCheckForProductUpdateResponse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LRResponse.check_for_product_update_response)
  return payload_.check_for_product_update_response_;
}

inline bool LRResponse::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void LRResponse::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline LRResponse::PayloadCase LRResponse::payload_case() const {
  return LRResponse::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LREvent

// .logi.proto.LRProvisioningDataAvailableEvent provisioning_data_available_event = 1;
inline bool LREvent::has_provisioning_data_available_event() const {
  return payload_case() == kProvisioningDataAvailableEvent;
}
inline void LREvent::set_has_provisioning_data_available_event() {
  _oneof_case_[0] = kProvisioningDataAvailableEvent;
}
inline const ::logi::proto::LRProvisioningDataAvailableEvent& LREvent::_internal_provisioning_data_available_event() const {
  return *payload_.provisioning_data_available_event_;
}
inline ::logi::proto::LRProvisioningDataAvailableEvent* LREvent::release_provisioning_data_available_event() {
  // @@protoc_insertion_point(field_release:logi.proto.LREvent.provisioning_data_available_event)
  if (has_provisioning_data_available_event()) {
    clear_has_payload();
      ::logi::proto::LRProvisioningDataAvailableEvent* temp = payload_.provisioning_data_available_event_;
    payload_.provisioning_data_available_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::logi::proto::LRProvisioningDataAvailableEvent& LREvent::provisioning_data_available_event() const {
  // @@protoc_insertion_point(field_get:logi.proto.LREvent.provisioning_data_available_event)
  return has_provisioning_data_available_event()
      ? *payload_.provisioning_data_available_event_
      : *reinterpret_cast< ::logi::proto::LRProvisioningDataAvailableEvent*>(&::logi::proto::_LRProvisioningDataAvailableEvent_default_instance_);
}
inline ::logi::proto::LRProvisioningDataAvailableEvent* LREvent::mutable_provisioning_data_available_event() {
  if (!has_provisioning_data_available_event()) {
    clear_payload();
    set_has_provisioning_data_available_event();
    payload_.provisioning_data_available_event_ = CreateMaybeMessage< ::logi::proto::LRProvisioningDataAvailableEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LREvent.provisioning_data_available_event)
  return payload_.provisioning_data_available_event_;
}

// .logi.proto.LRProductUpdatedEvent product_updated_event = 2;
inline bool LREvent::has_product_updated_event() const {
  return payload_case() == kProductUpdatedEvent;
}
inline void LREvent::set_has_product_updated_event() {
  _oneof_case_[0] = kProductUpdatedEvent;
}
inline const ::logi::proto::LRProductUpdatedEvent& LREvent::_internal_product_updated_event() const {
  return *payload_.product_updated_event_;
}
inline ::logi::proto::LRProductUpdatedEvent* LREvent::release_product_updated_event() {
  // @@protoc_insertion_point(field_release:logi.proto.LREvent.product_updated_event)
  if (has_product_updated_event()) {
    clear_has_payload();
      ::logi::proto::LRProductUpdatedEvent* temp = payload_.product_updated_event_;
    payload_.product_updated_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::logi::proto::LRProductUpdatedEvent& LREvent::product_updated_event() const {
  // @@protoc_insertion_point(field_get:logi.proto.LREvent.product_updated_event)
  return has_product_updated_event()
      ? *payload_.product_updated_event_
      : *reinterpret_cast< ::logi::proto::LRProductUpdatedEvent*>(&::logi::proto::_LRProductUpdatedEvent_default_instance_);
}
inline ::logi::proto::LRProductUpdatedEvent* LREvent::mutable_product_updated_event() {
  if (!has_product_updated_event()) {
    clear_payload();
    set_has_product_updated_event();
    payload_.product_updated_event_ = CreateMaybeMessage< ::logi::proto::LRProductUpdatedEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:logi.proto.LREvent.product_updated_event)
  return payload_.product_updated_event_;
}

inline bool LREvent::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void LREvent::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline LREvent::PayloadCase LREvent::payload_case() const {
  return LREvent::PayloadCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace logi

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::logi::proto::LogiRaidenMessage_Source> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::logi::proto::LogiRaidenMessage_Source>() {
  return ::logi::proto::LogiRaidenMessage_Source_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_cloud_5fmessage_2eproto
